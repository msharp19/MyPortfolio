<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightWire.Net4</name>
    </assembly>
    <members>
        <member name="T:BrightWire.Bayesian.BernoulliNaiveBayesClassifier">
            <summary>
            Bernoulli naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.BernoulliNaiveBayesClassifier.Classify(BrightWire.Models.IndexList)">
            <summary>
             Naive bayes values should only be used for ranking against each other
            </summary>
        </member>
        <member name="T:BrightWire.Bayesian.MultinomialNaiveBayesClassifier">
            <summary>
            Multinomial naive bayes classifer
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.MultinomialNaiveBayesClassifier.Classify(BrightWire.Models.IndexList)">
            <summary>
             Naive bayes values should only be used for ranking against each other
            </summary>
        </member>
        <member name="T:BrightWire.Bayesian.NaiveBayesClassifier">
            <summary>
            Naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.NaiveBayesClassifier.Classify(BrightWire.IRow)">
            <summary>
            Naive bayes classifications should only be used for ranking against each other and not for deriving an actual weighted probability
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Bayesian.Training.MarkovModelTrainer2`1">
            <summary>
            Builds markov models with a window size of 2
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightWire.Bayesian.Training.NaiveBayesTrainer">
            <summary>
            Simple naive bayes trainer
            </summary>
        </member>
        <member name="T:BrightWire.BrightWireProvider">
            <summary>
            Main entry point
            </summary>
        </member>
        <member name="M:BrightWire.BrightWireProvider.ParseCSV(System.IO.StreamReader,System.Char,System.Nullable{System.Boolean},System.IO.Stream)">
            <summary>
            Parses a CSV file into a data table
            </summary>
            <param name="streamReader">The stream of CSV data</param>
            <param name="delimeter">The CSV delimeter</param>
            <param name="hasHeader">True if there is a header</param>
            <param name="output">A stream to write the data table to (for file based processing) - null for in memory processing</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.ParseCSV(System.String,System.Char,System.Nullable{System.Boolean},System.IO.Stream)">
            <summary>
            Parses a CSV string into a data table
            </summary>
            <param name="csv">The string to parse</param>
            <param name="delimeter">The CSV delimeter</param>
            <param name="hasHeader">True if there is a header</param>
            <param name="output">A stream to write the data table to (for file based processing) - null for in memory processing</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.BrightWireProvider.ParseCSVToText(System.IO.StreamReader,System.Char,System.Nullable{System.Boolean},System.IO.Stream)">
            <summary>
            Parses CSV into a data table without type detection - all columns will be strings
            </summary>
            <param name="streamReader">The streamn reader that contains the CSV to parse</param>
            <param name="delimeter">The CSV delimeter</param>
            <param name="hasHeader">True if there is a header</param>
            <param name="output">A stream to write the data table to (for file based processing) - null for in memory processing</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.BrightWireProvider.ParseCSVToText(System.String,System.Char,System.Nullable{System.Boolean},System.IO.Stream)">
            <summary>
            Parses CSV into a data table without type detection - all columns will be strings
            </summary>
            <param name="csv">The string to parse</param>
            <param name="delimeter">>The CSV delimeter</param>
            <param name="hasHeader">True if there is a header</param>
            <param name="output">A stream to write the data table to (for file based processing) - null for in memory processing</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateDataTable(System.IO.Stream,System.IO.Stream)">
            <summary>
            Creates a data table from a stream
            </summary>
            <param name="dataStream">The stream that the data table was written to</param>
            <param name="indexStream">The stream that the index was written to (optional)</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateLegacyDataTable(System.IO.Stream,System.IO.Stream)">
            <summary>
            Creates a data table from a stream (created from versions below 2.1)
            </summary>
            <param name="dataStream">The stream that the data table was written to</param>
            <param name="indexStream">The stream that the index was written to (optional)</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateLinearAlgebra(System.Boolean)">
            <summary>
            Creates a linear algebra provider that runs on the CPU
            </summary>
            <param name="stochastic">False to use the same random number generation each time</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateDataTableBuilder(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a data table builder to programatically create data tables
            </summary>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateDataTableBuilder(System.Collections.Generic.IEnumerable{BrightWire.IColumn},System.IO.Stream,System.Boolean)">
            <summary>
            Creates a data table builder to programatically create data tables
            </summary>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateMarkovTrainer2``1(System.Int32)">
            <summary>
            Create a markov model trainer of window size 2
            </summary>
            <typeparam name="T">The markov chain data type</typeparam>
            <param name="minObservations">Minimum number of data points to record an observation</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateMarkovTrainer3``1(System.Int32)">
            <summary>
            Create a markov model trainer of window size 3
            </summary>
            <typeparam name="T">The markov chain data type</typeparam>
            <param name="minObservations">Minimum number of data points to record an observation</param>
        </member>
        <member name="M:BrightWire.BrightWireProvider.CreateTypeConverter``1(``0)">
            <summary>
            Returns a generic type converter that uses a default value if conversion fails
            </summary>
            <typeparam name="T">Type to conver to</typeparam>
            <param name="defaultValue">Value to use if the conversion fails</param>
        </member>
        <member name="T:BrightWire.Descriptor.AdaGradDescriptor">
            <summary>
            Creates an AdaGrad gradient descent optimisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.AdamDescriptor">
            <summary>
            Creates an adam gradient descent optimisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.L1RegularisationDescriptor">
            <summary>
            Creates L1 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.L2RegularisationDescriptor">
            <summary>
            Creates L2 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.MomentumDescriptor">
            <summary>
            Creates a momentum gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.NesterovMomentumDescriptor">
            <summary>
            Creates a nesterov momentum gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.RmsPropDescriptor">
            <summary>
            Creates a rms prop gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.Backpropagate">
            <summary>
            Backpropagates the graph against the error metric
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.BackpropagateThroughTime">
            <summary>
            Backpropagates through time (for recurrent neural networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.ConstrainSignal">
            <summary>
            Constrains the signal through the graph to lie between two values
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.CopyNamedMemory">
            <summary>
            Copies named memory from one slot to another
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.JoinInputWithMemory">
            <summary>
            Joins the graph signal with a saved signal stored in named memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.SetMemory">
            <summary>
            Saves the current graph signal into named memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.LeakyRelu">
            <summary>
            Leaky RELU activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Relu">
            <summary>
            RELu activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Sigmoid">
            <summary>
            Sigmoid activation function
            https://en.wikipedia.org/wiki/Sigmoid_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.SoftMax">
            <summary>
            Softmax activation function
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Tanh">
            <summary>
            Tanh activation function
            https://en.wikipedia.org/wiki/Activation_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataSource.SequentialDataSource">
            <summary>
            Feeds sequential data to the graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataSource.VectorDataSource">
            <summary>
            Feeds data to the execution graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.AdaptiveDataTableAdaptorBase">
            <summary>
            Base class for data table adaptors that adapt their input based on a preliminary execution graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1">
            <summary>
            Base class for data table based data adaptors
            </summary>
            <typeparam name="T">The type of the cached data</typeparam>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._dataColumnIndex">
            <summary>
            The data table columns with attributes
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._dataTargetIndex">
            <summary>
            Target column index
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._lap">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._data">
            <summary>
            The list of raw row data
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.#ctor(BrightWire.ILinearAlgebraProvider,BrightWire.IDataTable)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.InputCount">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.IsSequential">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.InputSize">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.OutputSize">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.RowCount">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.Get(BrightWire.IExecutionContext,System.Collections.Generic.IReadOnlyList{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.CloneWith(BrightWire.IDataTable)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.GetBuckets">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1.OnBatchProcessed(BrightWire.IContext)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._GetRows(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Returns the row data
            </summary>
            <param name="rows">List of row indices</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._GetMiniBatch(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Single[][],System.Single[]}})">
            <summary>
            Creates a mini batch
            </summary>
            <param name="rows">Row indices</param>
            <param name="data">List of input/output tuples</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase`1._GetSequentialMiniBatch(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.ValueTuple{BrightWire.Models.FloatMatrix,BrightWire.Models.FloatMatrix}})">
            <summary>
            Creates a sequential mini batch
            </summary>
            <param name="rows">Row indices</param>
            <param name="data">List of input/output matrix tuples</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.DefaultDataTableAdaptor">
            <summary>
            Vectorises each row of the data table on demand
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.IndexListDataTableAdaptor">
            <summary>
            Adapts data tables with a index list based column (corresponding to an unweighted sparse vector)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.ManyToOneDataTableAdaptor">
            <summary>
            Adapts data tables that classify a sequence into a single classification
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.OneToManyDataTableAdaptor">
            <summary>
            Adapts data tables that generate sequences from a single vector
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.RowBasedDataTableAdaptorBase">
            <summary>
            Base class for data tables that work with data table rows
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdaptor.RowBasedDataTableAdaptorBase.#ctor(BrightWire.ILinearAlgebraProvider,BrightWire.IDataTable)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.SequenceToSequenceDataTableAdaptor">
            <summary>
            Executes a preliminary graph and uses its output as the input for the main graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.SequentialDataTableAdaptor">
            <summary>
            Adapts data tables that classify each step of a sequence
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.TensorBasedDataTableAdaptor">
            <summary>
            Adapts data tables that classify tensors (volumes)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.VectorBasedDataTableAdaptor">
            <summary>
            Data table adaptor for tables with vector data
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdaptor.WeightedIndexListDataTableAdaptor">
            <summary>
            Adapts data tables with a weighted index list based column (corresponding to a sparse vector)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.ExecutionEngine">
            <summary>
            Executes (without training) graphs
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.ExecutionContext">
            <summary>
            Graph engine execution context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.ExecutionEngineContext">
            <summary>
            Execution engine context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.LearningContext">
            <summary>
            Graph engine learning context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.SequentialRowDataSource">
            <summary>
            Helper class when executing a single sequence
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.SingleRowDataSource">
            <summary>
            Helper class when executing a single row instead of the normal batch mode
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.TrainingEngineContext">
            <summary>
            Training engine context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.TrainingEngine">
            <summary>
            Trains graphs as it executes them
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.BinaryClassification">
            <summary>
            Binary classification rounds outputs to 1 or 0 and compares them against the target
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.CrossEntropy">
            <summary>
            Cross entropy error
            https://en.wikipedia.org/wiki/Cross_entropy#Cross-entropy_error_function_and_logistic_regression
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.OneHotEncoding">
            <summary>
            Finds the single index of the highest activation and compares it to the target index
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.Quadratic">
            <summary>
            Quadratic error
            https://en.wikipedia.org/wiki/Mean_squared_error#Loss_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.AdaGrad">
            <summary>
            AdaGrad gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.Adam">
            <summary>
            Adam gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.L1Regularisation">
            <summary>
            L1 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.L2Regularisation">
            <summary>
            L2 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.Momentum">
            <summary>
            Gradient descent with momentum
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.NesterovMomentum">
            <summary>
            Gradient descent with nesterov momentum
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.RmsProp">
            <summary>
            Rms prop gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#RMSProp
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.StochasticGradientDescent">
            <summary>
            Simple SGD
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory">
            <summary>
            Creates graph nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.#ctor(BrightWire.ILinearAlgebraProvider,BrightWire.IPropertySet)">
            <summary>
            Constructor
            </summary>
            <param name="lap">The linear algebra provider to use</param>
            <param name="propertySet">A property set with initialisation data (optional)</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.CurrentPropertySet">
            <summary>
            The current property set
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.PushPropertySet(System.Action{BrightWire.IPropertySet})">
            <summary>
            Clones the current property set with an optional mutator and then pushes it onto the stack
            </summary>
            <param name="mutator">Callback that can modify the cloned property set</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.PopPropertyStack">
            <summary>
            Pops the last property set from the stack
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateWeightUpdater(BrightWire.IMatrix)">
            <summary>
            Creates a gradient descent optimiser for the given matrix
            </summary>
            <param name="weight"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateExecutionContext">
            <summary>
            Creates a graph execution context
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateLearningContext(System.Single,System.Int32,BrightWire.TrainingErrorCalculation,System.Boolean)">
            <summary>
            Creates a graph learning context
            </summary>
            <param name="learningRate">Initial learning rate</param>
            <param name="batchSize">Mini batch size</param>
            <param name="trainingErrorCalculation">How to calculate the training error</param>
            <param name="deferUpdates">True to defer updates (used when training recurrent neural networks)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTrainingEngine(BrightWire.IDataSource,System.Single,System.Int32,BrightWire.TrainingErrorCalculation)">
            <summary>
            Creates a graph training engine
            </summary>
            <param name="dataSource">Data source with training data</param>
            <param name="learningRate">Initial learning rate</param>
            <param name="batchSize">Mini batch size</param>
            <param name="trainingErrorCalculation">How to calculate the training error</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTrainingEngine(BrightWire.IDataSource,BrightWire.Models.ExecutionGraph,System.Single,System.Int32,BrightWire.TrainingErrorCalculation)">
            <summary>
            Creates a graph training engine
            </summary>
            <param name="dataSource">Data source with training data</param>
            <param name="graph">The serialised graph to execute</param>
            <param name="trainingRate">Initial learning rate</param>
            <param name="batchSize">Mini batch size</param>
            <param name="trainingErrorCalculation">How to calculate the training error</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTrainingEngine(BrightWire.IDataSource,BrightWire.ILearningContext,BrightWire.Models.ExecutionGraph)">
            <summary>
            Creates a graph training engine
            </summary>
            <param name="dataSource">Data source with training data</param>
            <param name="learningContext">Previously created training context</param>
            <param name="graph">The serialised graph to execute (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateEngine(BrightWire.Models.ExecutionGraph)">
            <summary>
            Creates a graph execution engine
            </summary>
            <param name="graph">The serialised graph to execute</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatVector})">
            <summary>
            Creates a data source from a list of vectors
            </summary>
            <param name="vectorList">The list of vectors that will be the rows in the data source</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatMatrix})">
            <summary>
            Creates a data source from a list of matrices (sequential vectors)
            </summary>
            <param name="sequenceList">The list of matrices that will be the rows in the data source</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatTensor})">
            <summary>
            Creates a data source from a list of tensors
            </summary>
            <param name="tensorList">The list of tensors that will be the rows in the data source</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightWire.IDataTable,BrightWire.IDataTableVectoriser)">
            <summary>
            Creates a data source from a data table
            </summary>
            <param name="dataTable">The data table to convert</param>
            <param name="vectoriser">Optional data table vectoriser (if the data table contains categorical or index based data)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightWire.IDataTable,BrightWire.ILearningContext,System.Action{BrightWire.ExecutionGraph.WireBuilder})">
            <summary>
            Creates an adaptive data source (that uses the output from a preliminary graph)
            </summary>
            <param name="dataTable">Data that will be sent to the preliminary graph</param>
            <param name="learningContext">Learning context to use while training the preliminary graph</param>
            <param name="dataConversionBuilder">Callback to build the preliminary graph</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightWire.IDataTable,BrightWire.Models.DataSourceModel,BrightWire.ILearningContext)">
            <summary>
            Creates an adaptive data source from a serialised model
            </summary>
            <param name="dataTable">Data that will be sent to the preliminary graph</param>
            <param name="dataSource">The serialised preliminary graph</param>
            <param name="learningContext">Learning context to use while training the preliminary graph</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateClassifier(BrightWire.IRowClassifier,BrightWire.IDataTable,BrightWire.IDataTableAnalysis,System.String)">
            <summary>
            Create a row classifier node
            </summary>
            <param name="classifier">The classifier for each row</param>
            <param name="dataTable">The data table that contains the rows to classify (linked by mini batch index)</param>
            <param name="analysis">Optional data table analysis data</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateFeedForward(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a feed forward layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDropConnect(System.Single,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)
            </summary>
            <param name="dropoutPercentage">Percentage of connections to drop (0..1)</param>
            <param name="inputSize">Number of incoming connections</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTiedFeedForward(BrightWire.IFeedForward,System.String)">
            <summary>
            Creates a layer whose weights are shared with another layer (but transposed)
            </summary>
            <param name="layer">The layer that shares weights</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateConvolutional(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Creates a convolutional layer
            </summary>
            <param name="inputDepth">Input depth</param>
            <param name="filterCount">Number of convolutional filters</param>
            <param name="padding">Padding to apply before convolutions</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="stride">Convolutional stride</param>
            <param name="shouldBackpropagate">True to calculate the backpropagation error signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateMaxPool(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a max pooling convolutional layer
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="stride"></param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateSimpleRecurrent(System.Int32,System.Single[],BrightWire.INode,System.String)">
            <summary>
            Creates a simple recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="activation">Activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateElman(System.Int32,System.Single[],BrightWire.INode,BrightWire.INode,System.String)">
            <summary>
            Creates an Elman recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateJordan(System.Int32,System.Single[],BrightWire.INode,BrightWire.INode,System.String)">
            <summary>
            Creates a Jordan recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateOneMinusInput(System.String)">
            <summary>
            Creates a node that subtracts each input from 1 (1-x)
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateSequenceReverser(System.Int32,System.String)">
            <summary>
            Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)
            </summary>
            <param name="index">Input index to reverse</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateGru(System.Int32,System.Single[],System.String)">
            <summary>
            Creates a GRU recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateRan(System.Int32,System.Single[],System.String)">
            <summary>
            Creates a Recurrent Additive Layer (recurrent)
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateLstm(System.Int32,System.Single[],System.String)">
            <summary>
            Creates a LSTM recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memory">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDropOut(System.Single,System.String)">
            <summary>
            Creates a layer that drops random connections
            </summary>
            <param name="dropoutPercentage">Percentage to drop (0..1)</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateOutputNode(System.Int32,System.String)">
            <summary>
            Creates a node that writes the current forward signal as an output of the graph
            </summary>
            <param name="channel">Output channel</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Connect(BrightWire.IGraphTrainingEngine,System.Int32)">
            <summary>
            Builds a new wire from the engine's input node
            </summary>
            <param name="engine">Graph engine to build with</param>
            <param name="inputIndex">Input index to connect to</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Connect(System.Int32,BrightWire.INode)">
            <summary>
            Builds a new wire from the selected node
            </summary>
            <param name="inputSize">Number of outgoing connections</param>
            <param name="node">The node to build from</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Connect(System.Int32,System.Int32,System.Int32,BrightWire.INode)">
            <summary>
            Builds a new wire from the selected node
            </summary>
            <param name="width">Volume width</param>
            <param name="height">Volume height</param>
            <param name="depth">Volume depth</param>
            <param name="node">The node to build from</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Add(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Adds the output of two wires into a new wire
            </summary>
            <param name="input1">First wire</param>
            <param name="input2">Second wire</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Subtract(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Subtracts the second input from the first input and sends the result to a new wire
            </summary>
            <param name="input1">Wire to subtract from</param>
            <param name="input2">Wire to subtract</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Subtract(System.Int32,BrightWire.INode,BrightWire.INode,System.String)">
            <summary>
            Subtracts the second input from the first input and sends the result to a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">The node to subtract from</param>
            <param name="input2">The node to subtract</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Add(System.Int32,BrightWire.INode,BrightWire.INode,System.String)">
            <summary>
            Adds the output of two nodes together into a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">First node</param>
            <param name="input2">Second node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Multiply(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Multiplies the output of two wires into a new wire
            </summary>
            <param name="input1"></param>
            <param name="input2"></param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Multiply(System.Int32,BrightWire.INode,BrightWire.INode,System.String)">
            <summary>
            Multiplies the output of two nodes together into a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">First node</param>
            <param name="input2">Second node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Join(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Concatenates two wires together into a new wire
            </summary>
            <param name="input1">First wire to join</param>
            <param name="input2">Second wire to join</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.ReverseTemporalJoin(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Concatenates two wires together into a new wire, but reverses the temporal index of the second input to realign with reversed sequences
            </summary>
            <param name="forwardInput">Forward wire to join</param>
            <param name="backwardInput">Backward wire to join</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateWrapper(BrightWire.INode,System.String)">
            <summary>
            Wraps an existing node, enabling that node to be used at multiple locations in the same graph
            </summary>
            <param name="nodeToWrap">Node to wrap</param>
            <param name="name">Optional name to give the wrapping node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Create(BrightWire.Models.ExecutionGraph.Node)">
            <summary>
            Creates a node from it's serialised model
            </summary>
            <param name="node">The node model</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.LeakyReluActivation(System.String)">
            <summary>
            Creates a new leaky relu activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.ReluActivation(System.String)">
            <summary>
            Creates a new relu activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.SigmoidActivation(System.String)">
            <summary>
            Creates a new sigmoid activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.TanhActivation(System.String)">
            <summary>
            Creates a new tanh activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.SoftMaxActivation(System.String)">
            <summary>
            Creates a new softmax activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.ConstantWeightInitialisation(System.Single,System.Single)">
            <summary>
            Creates a constant weight initialiser
            </summary>
            <param name="biasValue">Single bias value</param>
            <param name="weightValue">Single weight value</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GaussianWeightInitialisation(System.Boolean,System.Single,BrightWire.GaussianVarianceCalibration,BrightWire.GaussianVarianceCount)">
            <summary>
            Creates a gaussian weight initialiser
            </summary>
            <param name="zeroBias">True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation</param>
            <param name="stdDev">Standard deviation of gaussian distribution</param>
            <param name="varianceCalibration">How to calibrate the variance</param>
            <param name="varianceCount">How to count connections while calibrating connections</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.IdentityWeightInitialisation(System.Single)">
            <summary>
            Creates an identity weight initialiser
            </summary>
            <param name="identityValue">The value to give to each diagonal value</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.XavierWeightInitialisation(System.Single)">
            <summary>
            Creates a xavier weight initialiser
            </summary>
            <param name="parameter">Xavier parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.AdaGrad">
            <summary>
            Creates an AdaGrad gradient descent optimiser
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Adam(System.Single,System.Single)">
            <summary>
            Creates an Adam gradient descent optimiser
            </summary>
            <param name="decay">Decay parameter</param>
            <param name="decay2">Second decay parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.L1(System.Single)">
            <summary>
            Creates a L1 regularisation gradient descent optimiser
            </summary>
            <param name="lambda">L1 parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.L2(System.Single)">
            <summary>
            Creates a L2 regularisation gradient descent optimiser
            </summary>
            <param name="lambda">L2 parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Momentum(System.Single)">
            <summary>
            Creats a momentum gradient descent optimiser
            </summary>
            <param name="momentum">Momentum parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.NesterovMomentum(System.Single)">
            <summary>
            Creates a nesterov momentum gradient descent optimiser
            </summary>
            <param name="momentum">Nesterov momentum parameter</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.RmsProp(System.Single)">
            <summary>
            Creates a rms prop gradient descent optimiser
            </summary>
            <param name="decay">Rms decay</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.SimpleGradientDescent">
            <summary>
            Uses vanilla stochastic gradient descent
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider">
            <summary>
            Prebuilt regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider.L1">
            <summary>
            L1 regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider.L2">
            <summary>
            L2 regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.Regularisation">
            <summary>
            Prebuilt regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider">
            <summary>
            Prebuilt gradient descent optimisers
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.AdaGrad">
            <summary>
            Adagrad gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.Adam">
            <summary>
            Adam gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.Momentum">
            <summary>
            Momentum gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.NesterovMomentum">
            <summary>
            Nesterov momentum gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.RmsProp">
            <summary>
            Rms prop gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescent">
            <summary>
            Prebuilt gradient descent optimisers
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider">
            <summary>
            Error metrics
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.BinaryClassification">
            <summary>
            Binary classification error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.CrossEntropy">
            <summary>
            Cross entropy error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.OneHotEncoding">
            <summary>
            One hot encoding error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.Quadratic">
            <summary>
            Quadratic error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetric">
            <summary>
            Error metrics
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider">
            <summary>
            Prebuilt weight initialisers
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Ones">
            <summary>
            All weights are initialised to 1
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Zeroes">
            <summary>
            All weights are initialised to 0
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Gaussian">
            <summary>
            Weights are randomly initialised using a gaussian distribution
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Xavier">
            <summary>
            Weights are randomly initialised using the xavier algorithm
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Identity">
            <summary>
            Weights are initialised to the identity matrix
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Identity01">
            <summary>
            Weights are initialised to the identity matrix / 10
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisation">
            <summary>
            Prebuilt weight initialisers
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider">
            <summary>
            Provides standard graph operations
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.OneDividedBy(System.String)">
            <summary>
            Calculates inverse (1/x) of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.InputSquared(System.String)">
            <summary>
            Calculates square (x^2) of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.SquareRootOf(System.String)">
            <summary>
            Calculates square root of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.OneMinusInput(System.String)">
            <summary>
            Caclculates one minus graph input (1-x)
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GraphOperation">
            <summary>
            Standard graph operations
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider">
            <summary>
            Provides standard graph actions
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider.Constrain(System.Single,System.Single)">
            <summary>
            Constrains the signal through the graph (either forward or backward)
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GraphAction">
            <summary>
            Standard graph actions
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MatrixGraphData">
            <summary>
            Graph data adaptor for matrices
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.Tensor3DGraphData">
            <summary>
            Graph data adaptor for 3D tensors
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.Tensor4DGraphData">
            <summary>
            Graph data adaptor for 4D tensors
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatch">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.MiniBatch">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.SequenceIndex">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Type">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Input">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Target">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},BrightWire.IDataSource,System.Collections.Generic.IReadOnlyList{BrightWire.IGraphData},BrightWire.IGraphData)">
            <summary>
            Creates a non sequential mini batch
            </summary>
            <param name="rows">The indices of the rows in this mini batch</param>
            <param name="dataSource">Associated data source</param>
            <param name="input">Mini batch input data</param>
            <param name="output">Expected output data (when training, otherwise null)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},BrightWire.IDataSource)">
            <summary>
            Creates a sequential mini batch
            </summary>
            <param name="rows">The indices of the rows in this mini batch</param>
            <param name="dataSource">Associated data source</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Add(BrightWire.MiniBatchSequenceType,System.Collections.Generic.IReadOnlyList{BrightWire.IGraphData},BrightWire.IGraphData)">
            <summary>
            Adds another item to the sequential mini batch
            </summary>
            <param name="type">Type of the sequential item</param>
            <param name="input">Mini batch input data</param>
            <param name="output">Expected output data (when training, otherwise null)</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Rows">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.DataSource">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.IsSequential">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.BatchSize">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.CurrentSequence">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.HasNextSequence">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.SequenceCount">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Reset">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.GetNextSequence">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.GetSequenceAtIndex(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatchProvider">
            <summary>
            Divides epochs into a list of mini batches
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.TrainingAction">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.TrainingAction.#ctor(BrightWire.INode,BrightWire.IGraphData,BrightWire.INode)">
            <summary>
            Creates a training action history from a single optional parent
            </summary>
            <param name="source">The node that executed</param>
            <param name="data">The output of the node</param>
            <param name="parent">The single parent that contributed to the output (optional)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.TrainingAction.#ctor(BrightWire.INode,BrightWire.IGraphData,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Creates a training action history from multiple parents
            </summary>
            <param name="source">The node that executed</param>
            <param name="data">The output of the node</param>
            <param name="parents">The parent nodes that contributed to the output</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.TrainingAction.Source">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.TrainingAction.Data">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.TrainingAction.Backpropagation">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.TrainingAction.Parents">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.WireToNode">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.WireToNode.#ctor(BrightWire.INode,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="node">The destination node</param>
            <param name="channel">The input channel on the node</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.WireToNode.SendTo">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.WireToNode.Channel">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.BackpropagationBase`1">
            <summary>
            Base class for node backpropagation
            </summary>
            <typeparam name="T">The node type</typeparam>
        </member>
        <member name="F:BrightWire.ExecutionGraph.Node.BackpropagationBase`1._source">
            <summary>
            The node that generated the forward signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="source">The node that generated the forward signal</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1._Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="isDisposing"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Backward(BrightWire.INode,BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Called when backpropagating
            </summary>
            <param name="fromNode">The node that sent the backpropagation signal</param>
            <param name="errorSignal">The backpropagating error</param>
            <param name="context">Graph context</param>
            <param name="parents">Parents of the current node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1._Backward(BrightWire.INode,BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Called when a valid error signal has been received
            </summary>
            <param name="fromNode">>The node that sent the backpropagation signal</param>
            <param name="errorSignal">The backpropagating error</param>
            <param name="context">Graph context</param>
            <param name="parents">Parents of the current node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1._SendErrorTo(BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Sends a backpropagation signal further up the graph
            </summary>
            <param name="errorSignal">The backpropagating error</param>
            <param name="context">Graph context</param>
            <param name="parents">Parents of the current node</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Filter.DropConnect">
            <summary>
            Drop connect (inverted) regularisation
            http://cs.nyu.edu/~wanli/dropc/
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Filter.DropOut">
            <summary>
            Drop out (inverted) regularisation
            https://en.wikipedia.org/wiki/Dropout_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.AddGate">
            <summary>
            Outputs the two input signals added together
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase">
            <summary>
            Base class for nodes that accept two input signals and output one signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase.ExecuteForward(BrightWire.IContext)">
            <summary>
            Executes on the primary channel
            </summary>
            <param name="context">The graph context</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase._ExecuteForward(BrightWire.IContext,System.Int32)">
            <summary>
            Executes on a secondary channel
            </summary>
            <param name="context">The graph context</param>
            <param name="channel">The channel</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase._Activate(BrightWire.IContext,BrightWire.IMatrix,BrightWire.IMatrix)">
            <summary>
            When both the primary and secondary inputs have arrived
            </summary>
            <param name="context">Graph context</param>
            <param name="primary">Primary signal</param>
            <param name="secondary">Secondary signal</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase._AddHistory(BrightWire.IContext,BrightWire.IMatrix,System.Func{BrightWire.IBackpropagation})">
            <summary>
            Records the network activity
            </summary>
            <param name="context">Graph context</param>
            <param name="output">The output signal</param>
            <param name="backpropagation">Backpropagation creator (optional)</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase">
            <summary>
            Base class for nodes that accept input on an arbitary number of channels and output a single signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel">
            <summary>
            Information about an incoming signal
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Channel">
            <summary>
            The channel on which the signal was received
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Data">
            <summary>
            The signal
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Source">
            <summary>
            The node the signal came from
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Size">
            <summary>
            The size of the input signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">The size of the input signal</param>
            <param name="channel">The channel</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.SetData(BrightWire.IMatrix,BrightWire.INode)">
            <summary>
            Sets data
            </summary>
            <param name="data">The node signal</param>
            <param name="source">The source node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Clear">
            <summary>
            Clears the data
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.IsValid">
            <summary>
            True if a signal has been received
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.#ctor(System.String,BrightWire.ExecutionGraph.WireBuilder[])">
            <summary>
            Constructor
            </summary>
            <param name="name">The name of the node (optional)</param>
            <param name="incoming">The list of incoming wires</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.ExecuteForward(BrightWire.IContext)">
            <summary>
            Executes on the primary channel
            </summary>
            <param name="context">The graph context</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase._ExecuteForward(BrightWire.IContext,System.Int32)">
            <summary>
            Executes on a secondary channel
            </summary>
            <param name="context">The graph context</param>
            <param name="channel">The channel</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase._Activate(BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel})">
            <summary>
            Called when all registered inputs have arrived
            </summary>
            <param name="context">The graph context</param>
            <param name="data">The list of incoming signals</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase._AddHistory(BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel},BrightWire.IMatrix,System.Func{BrightWire.IBackpropagation})">
            <summary>
            Records the network activity
            </summary>
            <param name="context">The graph context</param>
            <param name="data">The list of incoming signals</param>
            <param name="output">Output signal</param>
            <param name="backpropagation">Backpropagation creator (optional)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase._GetInfo">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiplyGate">
            <summary>
            Outputs the two input signals multiplied together
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.SubtractGate">
            <summary>
            Subtracts the second input from the first input
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.ExecuteBackwardAction">
            <summary>
            Executes an action when backpropagating
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.ExecuteForwardAction">
            <summary>
            Executes an action when executing forward
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.HookErrorSignal">
            <summary>
            Provides a hook into the backpropagation signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.RowClassifier">
            <summary>
            Executes a row based classifier
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.TransposeAndCombineSignal">
            <summary>
            Transpose the input and combine each depth slice - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.TransposeSignal">
            <summary>
            Transpose the input - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.FlowThrough">
            <summary>
            Simple pass through of the input signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.MemoryFeeder">
            <summary>
            Feeds memory into the graph from a named memory slot
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.OneToMany">
            <summary>
            Waits for all children to finish backpropagating before sending the error further backward
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.ReverseSequence">
            <summary>
            Inputs the opposite sequential item from the input index (for bidirectional recurrent neural networks)
            https://en.wikipedia.org/wiki/Bidirectional_recurrent_neural_networks
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.BatchNorm">
            <summary>
            Batch normalisation layer
            https://arxiv.org/abs/1502.03167
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.Convolutional">
            <summary>
            Convolutional neural network layer
            https://en.wikipedia.org/wiki/Convolutional_neural_network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.ElmanJordan">
            <summary>
            Elman or Joran style recurrent neural network
            https://en.wikipedia.org/wiki/Recurrent_neural_network#Elman_networks_and_Jordan_networks
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.FeedForward">
            <summary>
            Feed forward neural network
            https://en.wikipedia.org/wiki/Feedforward_neural_network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.GatedRecurrentUnit">
            <summary>
            GRU recurrent neural network
            https://en.wikipedia.org/wiki/Gated_recurrent_unit
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.LongShortTermMemory">
            <summary>
            LSTM recurrent neural network
            https://en.wikipedia.org/wiki/Long_short-term_memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.MaxPool">
            <summary>
            Max pooling convolutional neural network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer">
            <summary>
            Implementation of Recurrent Additive Network
            http://www.kentonl.com/pub/llz.2017.pdf
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer.Output">
            <summary>
            Expose the output node so that we can append nodes to it
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer.SubNodes">
            <summary>
            The list of sub nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer.ExecuteForward(BrightWire.IContext)">
            <summary>
            Execute on the the start node, which will execute each sub node in turn
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.SimpleRecurrent">
            <summary>
            Simple recurrent neural network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.TiedFeedForward">
            <summary>
            A feed forward layer with tied weights (from a previous feed forward layer)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.NodeBase">
            <summary>
            Base class for graph nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">The name of the node (optional)</param>
            <param name="id">The node's unique id (optional)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._Initalise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.Byte[])">
            <summary>
            Called when serialising the node
            </summary>
            <param name="graph">Graph factory</param>
            <param name="description">Node description</param>
            <param name="data">Node serialisation data</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Dispose">
            <summary>
            Disposal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._Dispose(System.Boolean)">
            <summary>
            Disposal
            </summary>
            <param name="isDisposing"></param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Id">
            <summary>
            The node's unique id
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Name">
            <summary>
            The node's name in the graph
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Output">
            <summary>
            The list of outgoing wires along which the output signal will be sent
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ExecuteForward(BrightWire.IContext)">
            <summary>
            Called when executing forward on the primary channel
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._ExecuteForward(BrightWire.IContext,System.Int32)">
            <summary>
            Called when executing forward on a non-primary channel
            </summary>
            <param name="context"></param>
            <param name="channel"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ExecuteForward(BrightWire.IContext,System.Int32)">
            <summary>
            Called when executing forward
            </summary>
            <param name="context"></param>
            <param name="channel"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._AddNextGraphAction(BrightWire.IContext,BrightWire.IGraphData,System.Func{BrightWire.IBackpropagation})">
            <summary>
            Records the node execution and queues the output nodes for execution
            </summary>
            <param name="context"></param>
            <param name="data"></param>
            <param name="backProp"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.SerialiseTo(System.Collections.Generic.HashSet{BrightWire.INode},System.Collections.Generic.List{BrightWire.Models.ExecutionGraph.Node},System.Collections.Generic.HashSet{BrightWire.Models.ExecutionGraph.Wire})">
            <summary>
            Serialise this node and any connected nodes
            </summary>
            <param name="existing">Set of nodes that have already been serialised in the current context</param>
            <param name="connectedTo">List of nodes this node is connected to</param>
            <param name="wireList">List of wires between all connected nodes</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._GetInfo">
            <summary>
            Returns serialisation information
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.OnDeserialise(System.Collections.Generic.IReadOnlyDictionary{System.String,BrightWire.INode})">
            <summary>
            Called after the graph has been completely deserialised
            </summary>
            <param name="graph">The complete graph</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialise the node
            </summary>
            <param name="writer">Binary writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Deserialise the node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="reader">Binary reader</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.BrightWire#ICanInitialiseNode#Initialise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.String,System.String,System.Byte[])">
            <summary>
            Initialise the node from serialised data
            </summary>
            <param name="factory">Graph factory</param>
            <param name="id">Unique id</param>
            <param name="name">Node name</param>
            <param name="description">Node description</param>
            <param name="data">Serialisation data</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.FindByName(System.String)">
            <summary>
            Finds a connected node by friendly name
            </summary>
            <param name="name">The node's name to search for</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.FindById(System.String)">
            <summary>
            Finds a connected node by id
            </summary>
            <param name="id">Unique id to find</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.SubNodes">
            <summary>
            The list of sub-nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._Serialise(BrightWire.INode,System.IO.BinaryWriter)">
            <summary>
            Serialise the node to the writer
            </summary>
            <param name="node">The node to serialise</param>
            <param name="writer">The binary writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._WriteData(System.Action{System.IO.BinaryWriter})">
            <summary>
            Helper function to write data to a binary writer
            </summary>
            <param name="callback">Callback to receive the writer</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._ReadFrom(System.Byte[],System.Action{System.IO.BinaryReader})">
            <summary>
            Helper function to read from a binary reader
            </summary>
            <param name="data">The data to read</param>
            <param name="callback">Callback to receive the writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase._Hydrate(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Reads serialisation information and creates a node
            </summary>
            <param name="factory"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.LoadParameters(BrightWire.Models.ExecutionGraph.Node)">
            <summary>
            Loads parameters into an existing node
            </summary>
            <param name="nodeData">Serialised node parameters</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.BatchMean">
            <summary>
            Calculates the mean across the batch 
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.OneDividedByInput">
            <summary>
            Calculates 1/x
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.OneMinusInput">
            <summary>
            Subtracts the input from one (1-x)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput">
            <summary>
            Calculates the square root of the input
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput.Backpropagation">
            <summary>
            Derivative of sqrt(x) is 0.5/sqrt(x)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.SingleBackpropagationBase`1">
            <summary>
            Base class for nodes that back propagate to a single parent
            </summary>
            <typeparam name="T">The node type</typeparam>
        </member>
        <member name="M:BrightWire.ExecutionGraph.SingleBackpropagationBase`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="source">The node that generated the forward signal</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.SingleBackpropagationBase`1._Backward(BrightWire.INode,BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Called when a valid error signal has been received
            </summary>
            <param name="fromNode">The node that sent the backpropagation signal</param>
            <param name="errorSignal">The backpropagating error</param>
            <param name="context">Graph context</param>
            <param name="parents">Parents of the current node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.SingleBackpropagationBase`1._Backpropagate(BrightWire.INode,BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Backpropagation implementation
            </summary>
            <param name="fromNode">The node that sent the backpropagation signal</param>
            <param name="errorSignal">The backpropagating error</param>
            <param name="context">Graph context</param>
            <param name="parents">Parents of the current node</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Constant">
            <summary>
            Initalises all weights to a constant
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Gaussian">
            <summary>
            Initialises weights randomly based on a gaussian distribution
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Identity">
            <summary>
            Identity matrix: https://arxiv.org/abs/1504.00941
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Xavier">
            <summary>
            Xavier weight initialisation
            http://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WireBuilder">
            <summary>
            Wires nodes together to build strands of a graph
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,System.Int32,BrightWire.INode)">
            <summary>
            Connects new nodes starting from the specified node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="size">Initial wire size</param>
            <param name="node">The node to build from</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,System.Int32,System.Int32,System.Int32,BrightWire.INode)">
            <summary>
            Connects new nodes starting from the specified node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="width">Initial input width</param>
            <param name="height">Initial input height</param>
            <param name="depth">Initial input depth</param>
            <param name="node">The node to build from</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,BrightWire.IGraphTrainingEngine,System.Int32)">
            <summary>
            Connects new nodes to the engine output node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="engine">Graph engine</param>
            <param name="inputIndex">Input index to connect</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.WireBuilder.CurrentSize">
            <summary>
            The current wire size
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.SetNewSize(System.Int32)">
            <summary>
            Changes the current size of the builder
            </summary>
            <param name="newSize">New wire builder size</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.IncrementSizeBy(System.Int32)">
            <summary>
            Changes the current wire's input size
            </summary>
            <param name="delta">Amount to add to the current wire size</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddClassifier(BrightWire.IRowClassifier,BrightWire.IDataTable,BrightWire.IDataTableAnalysis,System.String)">
            <summary>
            Connects a row classifier
            </summary>
            <param name="classifier"></param>
            <param name="dataTable"></param>
            <param name="analysis"></param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddFeedForward(System.Int32,System.String)">
            <summary>
            Adds a feed forward layer
            </summary>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddTiedFeedForward(BrightWire.IFeedForward,System.String)">
            <summary>
            Adds a feed forward layer whose weights are tied to a previous layer
            </summary>
            <param name="layer">The layer whose weights are tied</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddDropOut(System.Single,System.String)">
            <summary>
            Adds a drop out layer
            </summary>
            <param name="dropOutPercentage">Percentage of connections to drop</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddDropConnect(System.Single,System.Int32,System.String)">
            <summary>
            Adds a drop connect layer
            </summary>
            <param name="dropOutPercentage">Percentage of connections to drop</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddOutput(System.Int32,System.String)">
            <summary>
            Creates a node that writes the current forward signal as an output of the graph
            </summary>
            <param name="channel">Output channel</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.Add(BrightWire.INode)">
            <summary>
            Adds a node
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddForwardAction(BrightWire.IAction,System.String)">
            <summary>
            Adds an action that will be executed in the forward pass
            </summary>
            <param name="action">Action to execute</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackwardAction(BrightWire.IAction,System.String)">
            <summary>
            Adds an action that will be executed in the backward pass
            </summary>
            <param name="action">Action to execute</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBatchNormalisation(System.String)">
            <summary>
            Adds a batch normalisation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddSimpleRecurrent(BrightWire.INode,System.Single[],System.String)">
            <summary>
            Adds a simple recurrent neural network layer
            </summary>
            <param name="activation">Activation layer</param>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddSimpleRecurrent(BrightWire.INode,System.Int32,System.String)">
            <summary>
            Adds a simple recurrent neural network layer
            </summary>
            <param name="activation">Activation layer</param>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddElman(BrightWire.INode,BrightWire.INode,System.Single[],System.String)">
            <summary>
            Adds an Elman recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddElman(BrightWire.INode,BrightWire.INode,System.Int32,System.String)">
            <summary>
            Adds an Elman recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddJordan(BrightWire.INode,BrightWire.INode,System.Single[],System.String)">
            <summary>
            Adds a Jordan recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddJordan(BrightWire.INode,BrightWire.INode,System.Int32,System.String)">
            <summary>
            Adds a Jordan recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddGru(System.Single[],System.String)">
            <summary>
            Adds a gated recurrent unit recurrent neural network layer
            </summary>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddGru(System.Int32,System.String)">
            <summary>
            Adds a gated recurrent unit recurrent neural network layer
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddRan(System.Single[],System.String)">
            <summary>
            Adds a recurrent additive layer (recurrent)
            </summary>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddRan(System.Int32,System.String)">
            <summary>
            Adds a recurrent additive layer (recurrent)
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddLstm(System.Single[],System.String)">
            <summary>
            Adds a long short term memory recurrent neural network layer
            </summary>
            <param name="initialMemory">Initial memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddLstm(System.Int32,System.String)">
            <summary>
            Adds a long short term memory recurrent neural network layer
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ReverseSequence(System.Int32,System.String)">
            <summary>
            Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)
            </summary>
            <param name="name">Optional name to give the node</param>
            <param name="index">Input index to reverse</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddMaxPooling(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Adds a max pooling convolutional layer
            </summary>
            <param name="filterWidth">Width of max pooliing filter</param>
            <param name="filterHeight">Height of max pooling filter</param>
            <param name="stride">Filter stride</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddConvolutional(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Adds a convolutional layer
            </summary>
            <param name="filterCount">Number of filters in the layer</param>
            <param name="padding">Padding to add before applying the convolutions</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="stride">Filter stride</param>
            <param name="shouldBackpropagate">True to calculate a backpropagation signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.Transpose(System.String)">
            <summary>
            Transposes the graph signal to move between convolutional and non-convolutional layers
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.TransposeAndCombine(System.String)">
            <summary>
            Transposes the graph signal and merges each depth slice
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackpropagation(BrightWire.IErrorMetric,System.String)">
            <summary>
            Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes
            </summary>
            <param name="errorMetric">Error metric to calculate the error signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackpropagationThroughTime(BrightWire.IErrorMetric,System.String)">
            <summary>
            Adds backpropagation through time
            </summary>
            <param name="errorMetric">Error metric to calculate the error signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ConstrainForwardSignal(System.Single,System.Single,System.String)">
            <summary>
            Constrains the error signal in the forward direction
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ConstrainBackwardSignal(System.Single,System.Single,System.String)">
            <summary>
            Constrains the error signal in the backward direction
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.WriteNodeMemoryToSlot(System.String,BrightWire.IHaveMemoryNode,System.String)">
            <summary>
            Writes node memory to a named memory slot
            </summary>
            <param name="slotName">Memory slot name</param>
            <param name="node">The node to read</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.JoinInputWithMemory(System.String,System.String)">
            <summary>
            Concatenates the named memory slot with the input signal
            </summary>
            <param name="slotName">Memory slot name</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.Find(System.String)">
            <summary>
            Tries to find the specified node
            </summary>
            <param name="name">The friendly name of the node</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.WireBuilder.LastNode">
            <summary>
            The last added node
            </summary>
        </member>
        <member name="T:BrightWire.ExtensionMethods">
            <summary>
            Static extension methods
            </summary>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Int32})">
            <summary>
            Shuffles the enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="seq">The sequence to shuffle</param>
            <param name="randomSeed">The random seed to use or null for a random shuffle</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Shuffles the enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="seq">The sequence to shuffle</param>
            <param name="rnd">The random number generator to use</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Split``1(System.Collections.Generic.IReadOnlyList{``0},System.Double)">
            <summary>
            Splits a sequence into training and test splits
            </summary>
            <typeparam name="T">The type of the sequence</typeparam>
            <param name="seq">The sequence to split</param>
            <param name="trainPercentage">The percentage of the sequence to add to the training set</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Bag``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Bags (select with replacement) the input sequence
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The input sequence</param>
            <param name="count">The size of the output sequence</param>
            <param name="randomSeed">The random seed or null initialise randomlu</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetColumnType(BrightWire.ColumnType)">
            <summary>
            Returns the underlying .net type associated with the column type
            </summary>
            <param name="type">The column type</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ConvertToWeightedIndexList(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}},System.Boolean)">
            <summary>
            Converts the indexed classifications to weighted indexed classifications
            </summary>
            <param name="data"></param>
            <param name="groupByClassification">True to group by classification (i.e convert the bag to a set)</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}})">
            <summary>
            Converts indexed classifications to a data table
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Converts weighted index classifications to a data table
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.FloatVector}},System.Boolean)">
            <summary>
            Converts the vector classifications into a data table
            </summary>
            <param name="data"></param>
            <param name="preserveVectors">True to create a data table with a vector column type, false to to convert to columns of floats</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetMaxWeight(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Finds the greatest weight within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Find the greatest index within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}})">
            <summary>
            Find the greatest index within the index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Vectorise(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Converts the weighted index classification list to a list of dense vectors
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Classify(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}},BrightWire.IIndexListClassifier)">
            <summary>
            Classifies each row of the index classification list
            </summary>
            <param name="data"></param>
            <param name="classifier">The classifier to classify each item in the list</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Normalise(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Normalises the weighted index classification list to fit between 0 and 1
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TFIDF(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.WeightedIndexList}})">
            <summary>
            Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Tf%E2%80%93idf
            </summary>
            <returns>A new weighted classification set</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsRow(BrightWire.Models.FloatVector)">
            <summary>
            Adapts the vector as a row
            </summary>
            <param name="vector">Vector to treat as data table row</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ReverseNormaliseOutput(BrightWire.Models.DataTable.DataTableNormalisation,System.Int32,System.Object)">
            <summary>
            Applies a normalisation model in reverse
            </summary>
            <param name="model">Normalisation model</param>
            <param name="originalColumnIndex">Original column index</param>
            <param name="valueToConvert">Value to reverse</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ReverseVectoriseOutput(BrightWire.Models.DataTable.DataTableVectorisation,BrightWire.Models.FloatVector,BrightWire.ColumnType)">
            <summary>
            Applies a vectorisation model in reverse
            </summary>
            <param name="model">Vectorisation model</param>
            <param name="vector">Vector to reverse</param>
            <param name="targetColumnType">Original target column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateConfusionMatrix(BrightWire.IDataTable,System.Int32,System.Int32)">
            <summary>
            Creates a confusion matrix from two columns of a data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="actualClassificationColumnIndex">The column index of the actual classifications</param>
            <param name="expectedClassificationColumnIndex">The column index of the expected classifications</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Train(BrightWire.IGraphTrainingEngine,System.Int32,BrightWire.IDataSource,BrightWire.IErrorMetric,System.Action{BrightWire.Models.GraphModel},System.Int32)">
            <summary>
            Trains a graph for a fixed number of iterations
            </summary>
            <param name="engine">The graph training engine</param>
            <param name="numIterations">The number of iterations to train for</param>
            <param name="testData">The test data source to use</param>
            <param name="errorMetric">The error metric to evaluate the test data against</param>
            <param name="onImprovement">Optional callback for when the test data score has improved against the error metric</param>
            <param name="testCadence">Determines how many epochs elapse before the test data is evaluated</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Classifiy(BrightWire.IRowClassifier,BrightWire.IDataTable)">
            <summary>
            Classifies each row of the data table
            </summary>
            <param name="classifier"></param>
            <param name="dataTable"></param>
            <returns>A list of rows with their corresponding classifications</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetGraph(BrightWire.INode,System.String)">
            <summary>
            Serialises the node and any other connected nodes to an execution graph
            </summary>
            <param name="input"></param>
            <param name="name">Name of the graph (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateFrom(BrightWire.ExecutionGraph.GraphFactory,BrightWire.Models.ExecutionGraph)">
            <summary>
            Creates a node and any other connected nodes from a serialised execution graph
            </summary>
            <param name="factory"></param>
            <param name="graph">Serialised graph</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.OrderSequentialOutput(System.Collections.Generic.IReadOnlyList{BrightWire.Models.ExecutionResult})">
            <summary>
            Aligns the output of sequential graph execution into an ordered list of results
            </summary>
            <param name="results">Output from sequential graph execution</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Creates a vector based on an enumerable of floats
            </summary>
            <param name="lap"></param>
            <param name="data">The initial values in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,BrightWire.IIndexableVector)">
            <summary>
            Create a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Indexable vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,BrightWire.Models.FloatVector)">
            <summary>
            Create a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{System.Single})">
            <summary>
            Create a vector
            </summary>
            <param name="lap"></param>
            <param name="data">List of values</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,System.Single[])">
            <summary>
            Create a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Array of values</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateVector(BrightWire.ILinearAlgebraProvider,System.Int32,System.Single)">
            <summary>
            Create a vector
            </summary>
            <param name="lap"></param>
            <param name="length">Vector size</param>
            <param name="value">Constant value</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateZeroMatrix(BrightWire.ILinearAlgebraProvider,System.Int32,System.Int32)">
            <summary>
            Creates a matrix with every value initialised to zero
            </summary>
            <param name="lap"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Numer of columns</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrix(BrightWire.ILinearAlgebraProvider,BrightWire.Models.FloatMatrix)">
            <summary>
            Create a matrix
            </summary>
            <param name="lap"></param>
            <param name="matrix">Matrix to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrixFromRows(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatVector})">
            <summary>
            Create a matrix from a list of row vectors
            </summary>
            <param name="lap"></param>
            <param name="rowList">List of vectors (each vector becomes a row in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrixFromRows(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{BrightWire.IIndexableVector})">
            <summary>
            Create a matrix from a list of row vectors
            </summary>
            <param name="lap"></param>
            <param name="rowList">List of indexable vectors (each vector becomes a row in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrixFromColumns(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatVector})">
            <summary>
            Create a matrix from a list of column vectors
            </summary>
            <param name="lap"></param>
            <param name="columnList">List of vectors (each vector becomes a column in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrixFromColumns(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{BrightWire.IIndexableVector})">
            <summary>
            Create a matrix from a list of column vectors
            </summary>
            <param name="lap"></param>
            <param name="columnList">List of indexable vectors (each vector becomes a column in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrix(BrightWire.ILinearAlgebraProvider,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a matrix
            </summary>
            <param name="lap"></param>
            <param name="rows">Matrix rows</param>
            <param name="columns">Matrix columns</param>
            <param name="value">Constant value</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMatrix(BrightWire.ILinearAlgebraProvider,BrightWire.IIndexableMatrix)">
            <summary>
            Create a matrix
            </summary>
            <param name="lap"></param>
            <param name="matrix">Indexable matrix to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateIdentityMatrix(BrightWire.ILinearAlgebraProvider,System.Int32)">
            <summary>
            Create an identity matrix
            </summary>
            <param name="lap"></param>
            <param name="size">Width and height of the new matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateDiagonalMatrix(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{System.Single})">
            <summary>
            Create a diagonal matrix
            </summary>
            <param name="lap"></param>
            <param name="values">List of diagonal values</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Create3DTensor(BrightWire.ILinearAlgebraProvider,BrightWire.Models.FloatTensor)">
            <summary>
            Create a 3D tensor
            </summary>
            <param name="lap"></param>
            <param name="tensor">The serialised representation of the 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Create3DTensor(BrightWire.ILinearAlgebraProvider,BrightWire.Models.FloatMatrix[])">
            <summary>
            Creates a 3D tensor from a list of matrices
            </summary>
            <param name="lap"></param>
            <param name="matrices">List of matrices</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Calculate(BrightWire.DistanceMetric,BrightWire.IMatrix,BrightWire.IMatrix)">
            <summary>
            Calculates the distance between two matrices
            </summary>
            <param name="distance"></param>
            <param name="matrix1"></param>
            <param name="matrix2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Calculate(BrightWire.DistanceMetric,BrightWire.IVector,BrightWire.IVector)">
            <summary>
            Calculates the distance between two vectors
            </summary>
            <param name="distance"></param>
            <param name="vector1"></param>
            <param name="vector2"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightWire.IMatrix)">
            <summary>
            Converts the matrix to a generic IGraphData
            </summary>
            <param name="matrix">Matrix to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightWire.I3DTensor)">
            <summary>
            Converts the 3D tensor to a generic IGraphData
            </summary>
            <param name="tensor">Tensor to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightWire.I4DTensor)">
            <summary>
            Converts the 4D tensor to a generic IGraphData
            </summary>
            <param name="tensor">Tensor to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateRandomProjection(BrightWire.ILinearAlgebraProvider,System.Int32,System.Int32,System.Int32)">
            <summary>
            Random projections allow you to reduce the dimensions of a matrix while still preserving significant information
            </summary>
            <param name="lap">Linear algebra provider</param>
            <param name="fixedSize">The vector size to reduce from</param>
            <param name="reducedSize">The vector size to reduce to</param>
            <param name="s"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainLogisticRegression(BrightWire.IDataTable,BrightWire.ILinearAlgebraProvider,System.Int32,System.Single,System.Single,System.Func{System.Single,System.Boolean})">
            <summary>
            Trains a logistic regression model on a data table
            </summary>
            <param name="table">The training data</param>
            <param name="lap">Linear algebra provider</param>
            <param name="iterations">Number of iterations to train for</param>
            <param name="learningRate">The learning rate</param>
            <param name="lambda">Regularisation lambda</param>
            <param name="costCallback">Optional callback that is called after each iteration with the current cost</param>
            <returns>The trained model</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateLogisticRegressionTrainer(BrightWire.IDataTable,BrightWire.ILinearAlgebraProvider)">
            <summary>
            Logistic regression learns a sigmoid function over a set of data that learns to classify future values into positive or negative samples
            </summary>
            <param name="table">The training data provider</param>
            <param name="lap">Linear algebra provider</param>
            <returns>A trainer that can be used to build a logistic regression model</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetTransitions``1(System.Collections.Generic.Dictionary{BrightWire.Models.Bayesian.MarkovModelObservation2{``0},System.Collections.Generic.List{BrightWire.Models.Bayesian.MarkovModelStateTransition{``0}}},``0,``0)">
            <summary>
            Find the next set of state transitions from a pair of observations
            </summary>
            <typeparam name="T">The type of the model</typeparam>
            <param name="model">A markov model saved to a dictionary</param>
            <param name="item1">The first observation</param>
            <param name="item2">The second observation</param>
            <returns>The list of state transitions or null if nothing was found</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetTransitions``1(System.Collections.Generic.Dictionary{BrightWire.Models.Bayesian.MarkovModelObservation3{``0},System.Collections.Generic.List{BrightWire.Models.Bayesian.MarkovModelStateTransition{``0}}},``0,``0,``0)">
            <summary>
            Find the next set of state transitions from a tuple of observations
            </summary>
            <typeparam name="T">The type of the model</typeparam>
            <param name="model">A markov model saved to a dictionary</param>
            <param name="item1">The first observation</param>
            <param name="item2">The second observation</param>
            <param name="item3">The third observation</param>
            <returns>The list of state transitions or null if nothing was found</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.NNMF(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},BrightWire.ILinearAlgebraProvider,System.Int32,System.Int32)">
            <summary>
            Non negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.
            </summary>
            <param name="data">The training data</param>
            <param name="lap">Linear alegbra provider</param>
            <param name="k">The number of clusters</param>
            <param name="maxIterations">The maximum number of iterations</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.HierachicalCluster(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},System.Int32)">
            <summary>
            Hierachical clustering successively finds the closest distance between pairs of centroids until k is reached
            </summary>
            <param name="data">The list of vectors to cluster</param>
            <param name="k">The number of clusters to find</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.KMeans(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},BrightWire.ILinearAlgebraProvider,System.Int32,System.Int32,BrightWire.DistanceMetric)">
            <summary>
            K Means uses coordinate descent and a distance metric between randomly selected centroids to cluster the data
            </summary>
            <param name="data">The list of vectors to cluster</param>
            <param name="lap">Linear algebra provider</param>
            <param name="k">The number of clusters to find</param>
            <param name="maxIterations">The maximum number of iterations</param>
            <param name="distanceMetric">Distance metric to use to compare centroids</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainKNearestNeighbours(BrightWire.IDataTable)">
            <summary>
            K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications
            </summary>
            <param name="data">The training data</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainMultinomialLogisticRegression(BrightWire.IDataTable,BrightWire.ILinearAlgebraProvider,System.Int32,System.Single,System.Single,System.Func{System.Single,System.Boolean})">
            <summary>
            Multinomial Logistic Regression generalises Logistic Regression to multi-class classification
            </summary>
            <param name="data">The training data</param>
            <param name="lap">Linear algebra provider</param>
            <param name="trainingIterations">Number of training iterations</param>
            <param name="trainingRate">Training rate</param>
            <param name="lambda">L2 regularisation</param>
            <param name="costCallback">Optional callback that is called after each iteration with the current cost</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainRandomForest(BrightWire.IDataTable,System.Int32)">
            <summary>
            Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting
            </summary>
            <param name="data">The training data</param>
            <param name="b">The number of trees in the forest</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainDecisionTree(BrightWire.IDataTable,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.
            </summary>
            <param name="data">The training data</param>
            <param name="minDataPerNode">Minimum number of data points per node to continue splitting</param>
            <param name="maxDepth">The maximum depth of each leaf</param>
            <param name="minInformationGain">The minimum information gain to continue splitting</param>
            <param name="maxAttributes">The maximum number of attributes to consider at each split</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainMultinomialNaiveBayes(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}})">
            <summary>
            Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.
            </summary>
            <param name="data">The training data</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainMultinomialNaiveBayes(BrightWire.IDataTable)">
            <summary>
            Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.
            </summary>
            <param name="table">The training data table that must have a index-list based column to classify against</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainBernoulliNaiveBayes(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightWire.Models.IndexList}})">
            <summary>
            Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.
            </summary>
            <param name="data">The training data</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainBernoulliNaiveBayes(BrightWire.IDataTable)">
            <summary>
            Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.
            </summary>
            <param name="table">The training data table that must have an index-list based column</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainNaiveBayes(BrightWire.IDataTable)">
            <summary>
            Naive bayes is a classifier that assumes conditional independence between all features
            </summary>
            <param name="table">The training data provider</param>
            <returns>A naive bayes model</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateLinearRegressionTrainer(BrightWire.IDataTable,BrightWire.ILinearAlgebraProvider)">
            <summary>
            Linear regression fits a line to a set of data that allows you predict future values
            </summary>
            <param name="table">The training data table</param>
            <param name="lap">Linear algebra provider</param>
            <returns>A trainer that can be used to build a linear regression model</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetBestClassification(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,System.Single}})">
            <summary>
            Finds the classification with the highest weight
            </summary>
            <param name="classifications">List of weighted classifications</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.ConvertToRowClassifier(BrightWire.ILogisticRegressionClassifier,System.Collections.Generic.IReadOnlyList{System.Int32},System.String,System.String)">
            <summary>
            Converts the logistic regression classifier into a row classifier
            </summary>
            <param name="classifier">Logistic regression classifier to convert</param>
            <param name="attributeColumns">Attribute columns in data table to use</param>
            <param name="negativeLabel">Output classification for negative class label</param>
            <param name="positiveLabel">Output classification for the positive class label</param>
        </member>
        <member name="T:BrightWire.Helper.ConvolutionHelper">
            <summary>
            Helper class to calculate convolutional indices
            </summary>
        </member>
        <member name="M:BrightWire.Helper.ConvolutionHelper.LeftToRight(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates convolution indices from left to right
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="stride">Offset of each position</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="M:BrightWire.Helper.ConvolutionHelper.TopToBottom(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates convolution indices from top to bottom
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="stride">Offset of each position</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="T:BrightWire.Helper.ConvolutionHelper.ConvolutionalDelegate">
            <inheritdoc />
        </member>
        <member name="F:BrightWire.Helper.ConvolutionHelper.Default">
            <summary>
            Default convolutional direction
            </summary>
        </member>
        <member name="T:BrightWire.Helper.CSVParser">
            <summary>
            Simple CSV parser that attempts to detect data column types
            </summary>
        </member>
        <member name="T:BrightWire.Helper.DataTableBuilder">
            <summary>
            Builds data tables
            </summary>
        </member>
        <member name="T:BrightWire.Helper.DebugHelpers">
            <summary>
            Helper classes useful when debugging BW
            </summary>
        </member>
        <member name="M:BrightWire.Helper.DebugHelpers.WriteComparison(BrightWire.IIndexable3DTensor,BrightWire.IIndexable3DTensor)">
            <summary>
            Zips two tensors and writes the values side by side
            </summary>
            <param name="t1">First tensor</param>
            <param name="t2">Second tensor</param>
            <returns>Xml string</returns>
        </member>
        <member name="M:BrightWire.Helper.DebugHelpers.WriteComparison(BrightWire.IIndexable4DTensor,BrightWire.IIndexable4DTensor)">
            <summary>
            Zips two tensors and writes the values side by side
            </summary>
            <param name="t1">First tensor</param>
            <param name="t2">Second tensor</param>
            <returns>Xml string</returns>
        </member>
        <member name="M:BrightWire.Helper.DebugHelpers.WriteComparison(BrightWire.IIndexableMatrix,BrightWire.IIndexableMatrix)">
            <summary>
            Zips two matrices and writes the values side by side
            </summary>
            <param name="m1">First matrix</param>
            <param name="m2">Second matrix</param>
            <returns>Xml string</returns>
        </member>
        <member name="T:BrightWire.Helper.PropertySet">
            <summary>
            Property set implementation
            </summary>
        </member>
        <member name="T:BrightWire.Helper.RandomProjection">
            <summary>
            Implements random projection
            </summary>
        </member>
        <member name="T:BrightWire.Helper.VectorAsRow">
            <summary>
            Vector to data table row adaptor
            </summary>
        </member>
        <member name="T:BrightWire.Source.Helper.TypeLoader">
            <summary>
            Loads types in an assembly agnostic fashion
            </summary>
        </member>
        <member name="T:BrightWire.Source.Helper.VectorDistanceHelper">
            <summary>
            Calculates the distance between a list of vectors and a list of vectors to compare against
            </summary>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.#ctor(BrightWire.ILinearAlgebraProvider,System.Collections.Generic.IReadOnlyList{BrightWire.IVector},BrightWire.DistanceMetric)">
            <summary>
            Constructor
            </summary>
            <param name="lap">Linear algebra provider</param>
            <param name="data">List of vectors to compare</param>
            <param name="distanceMetric">Distance metric for comparison</param>
        </member>
        <member name="P:BrightWire.Source.Helper.VectorDistanceHelper.CompareTo">
            <summary>
            The list of vectors to compare against
            </summary>
        </member>
        <member name="P:BrightWire.Source.Helper.VectorDistanceHelper.Metric">
            <summary>
            Distance metric
            </summary>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.AddComparison(BrightWire.IVector)">
            <summary>
            Adds a comparison vector (will be owned and disposed by the helper class)
            </summary>
            <param name="comparison">Vector to compare against</param>
            <returns>Index of the comparison vector</returns>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.UpdateComparisonVector(System.Int32,BrightWire.IVector)">
            <summary>
            Updates the comparison vector at this index (disposes the old vector)
            </summary>
            <param name="index">Index to update</param>
            <param name="newVector">Vector to replace with</param>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.SetComparisonVectors(System.Collections.Generic.IReadOnlyList{BrightWire.IVector})">
            <summary>
            Updates the entire list of comparison vectors
            </summary>
            <param name="comparisonVectors">List of vectors to compare against</param>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.GetClosest">
            <summary>
            Returns the index of the closest comparison vector for each vector
            </summary>
        </member>
        <member name="M:BrightWire.Source.Helper.VectorDistanceHelper.GetAverageFromData(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Returns a vector averaged from the data vectors
            </summary>
            <param name="indices">Indices of the data vectors to use in the averaged vector</param>
        </member>
        <member name="T:BrightWire.InstanceBased.KNNClassifier">
            <summary>
            K Nearest Neighbour classifier
            </summary>
        </member>
        <member name="T:BrightWire.InstanceBased.Trainer.KNNClassificationTrainer">
            <summary>
            K Nearest Neighbour classification trainer
            </summary>
        </member>
        <member name="T:BrightWire.ICanSerialiseToStream">
            <summary>
            Standard serialisation interface
            </summary>
        </member>
        <member name="M:BrightWire.ICanSerialiseToStream.SerialiseTo(System.IO.Stream)">
            <summary>
            Writes the current object state to the stream
            </summary>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="M:BrightWire.ICanSerialiseToStream.DeserialiseFrom(System.IO.Stream,System.Boolean)">
            <summary>
            Reads the current object state from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="clear">True to clear the existing state</param>
        </member>
        <member name="T:BrightWire.NormalisationType">
            <summary>
            Data normalisation options
            </summary>
        </member>
        <member name="F:BrightWire.NormalisationType.Standard">
            <summary>
            Normalises based on standard deviation
            </summary>
        </member>
        <member name="F:BrightWire.NormalisationType.Manhattan">
            <summary>
            Normalise from manhattan distance
            </summary>
        </member>
        <member name="F:BrightWire.NormalisationType.Euclidean">
            <summary>
            Normalise from eucildean distance
            </summary>
        </member>
        <member name="F:BrightWire.NormalisationType.FeatureScale">
            <summary>
            Normalise based on min and max values
            </summary>
        </member>
        <member name="T:BrightWire.ColumnType">
            <summary>
            Data table column type
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Null">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Boolean">
            <summary>
            Boolean values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Byte">
            <summary>
            Byte values (-128 to 128)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Int">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Long">
            <summary>
            Long values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Float">
            <summary>
            Float values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Double">
            <summary>
            Double values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.String">
            <summary>
            String values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Date">
            <summary>
            Date values
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.IndexList">
            <summary>
            List of indices
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.WeightedIndexList">
            <summary>
            Weighted list of indices
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Vector">
            <summary>
            Vector of floats
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Matrix">
            <summary>
            Matrix of floats
            </summary>
        </member>
        <member name="F:BrightWire.ColumnType.Tensor">
            <summary>
            3D tensor of floats
            </summary>
        </member>
        <member name="T:BrightWire.IRow">
            <summary>
            A data table row
            </summary>
        </member>
        <member name="P:BrightWire.IRow.Index">
            <summary>
            The index of this row within the data table
            </summary>
        </member>
        <member name="P:BrightWire.IRow.Data">
            <summary>
            Gets the raw data from the row
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IRow.GetField``1(System.Int32)">
            <summary>
            Gets the value of the specified column (converted to T)
            </summary>
            <typeparam name="T">The type of data to return (will be converted if neccessary)</typeparam>
            <param name="index">The column index to query</param>
        </member>
        <member name="M:BrightWire.IRow.GetFields``1(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Gets the specified strongly typed values
            </summary>
            <typeparam name="T">The type of data to return (will be converted if neccessary)</typeparam>
            <param name="indices">The column indices to return</param>
        </member>
        <member name="P:BrightWire.IRow.Table">
            <summary>
            Returns the column information
            </summary>
        </member>
        <member name="T:BrightWire.IRowClassifier">
            <summary>
            A classifier that classifies a data table row
            </summary>
        </member>
        <member name="M:BrightWire.IRowClassifier.Classify(BrightWire.IRow)">
            <summary>
            Classifies the input data and returns the classifications with their weights
            </summary>
            <param name="row">The row to classify</param>
        </member>
        <member name="T:BrightWire.IIndexListClassifier">
            <summary>
            A classifier that classifies index lists
            </summary>
        </member>
        <member name="M:BrightWire.IIndexListClassifier.Classify(BrightWire.Models.IndexList)">
            <summary>
            Classifies the input data and returns the classifications with their weights
            </summary>
            <param name="indexList">The index list to classify</param>
        </member>
        <member name="T:BrightWire.IColumn">
            <summary>
            A column within a data table
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.Index">
            <summary>
            The index of the column within the data table
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.Name">
            <summary>
            The name of the column
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.Type">
            <summary>
            The data type
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.NumDistinct">
            <summary>
            The number of distinct values
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.IsContinuous">
            <summary>
            True if the value is continuous (not categorical)
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.IsTarget">
            <summary>
            True if the column is a classification target (or label)
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.DimensionX">
            <summary>
            Optional x dimension of the column (vector size, matrix/tensor columns)
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.DimensionY">
            <summary>
            Optional y dimension of the column (matrix/tensor rows)
            </summary>
        </member>
        <member name="P:BrightWire.IColumn.DimensionZ">
            <summary>
            Option z dimension of the column (tensor depth)
            </summary>
        </member>
        <member name="T:BrightWire.IHaveColumns">
            <summary>
            Column provider
            </summary>
        </member>
        <member name="P:BrightWire.IHaveColumns.Columns">
            <summary>
            The list of columns
            </summary>
        </member>
        <member name="P:BrightWire.IHaveColumns.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="T:BrightWire.IDataTableVectoriser">
            <summary>
            Converts data table rows to vectors
            </summary>
        </member>
        <member name="M:BrightWire.IDataTableVectoriser.GetInput(BrightWire.IRow)">
            <summary>
            Vectorises the input columns of the specified row
            </summary>
            <param name="row">The row to vectorise</param>
        </member>
        <member name="M:BrightWire.IDataTableVectoriser.GetOutput(BrightWire.IRow)">
            <summary>
            Vectorises the output column of the specified row
            </summary>
            <param name="row">The row to vectorise</param>
        </member>
        <member name="P:BrightWire.IDataTableVectoriser.InputSize">
            <summary>
            The size of the input vector
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableVectoriser.OutputSize">
            <summary>
            The size of the output vector
            </summary>
        </member>
        <member name="M:BrightWire.IDataTableVectoriser.GetOutputLabel(System.Int32,System.Int32)">
            <summary>
            Returns the classification label
            </summary>
            <param name="columnIndex">The data table column index</param>
            <param name="vectorIndex">The one hot vector index</param>
        </member>
        <member name="M:BrightWire.IDataTableVectoriser.GetVectorisationModel">
            <summary>
            Gets the serialisable model to recreate this vectorisation
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IDataTable">
            <summary>
            Tabular data table
            </summary>
        </member>
        <member name="P:BrightWire.IDataTable.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:BrightWire.IDataTable.TargetColumnIndex">
            <summary>
            The column of the classification target (defaults to the last column if none set)
            </summary>
        </member>
        <member name="M:BrightWire.IDataTable.Process(BrightWire.IRowProcessor)">
            <summary>
            Applies each row of the table to the specified processor
            </summary>
            <param name="rowProcessor">Will be called with each row</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetAnalysis(System.Boolean)">
            <summary>
            Data table statistics
            </summary>
            <param name="collectFrequency">True to also perform per column frequency analysis</param>
        </member>
        <member name="M:BrightWire.IDataTable.ForEach(System.Action{BrightWire.IRow})">
            <summary>
            Invokes the callback on each row in the table
            </summary>
            <param name="callback">Callback that is invoked for each row</param>
        </member>
        <member name="M:BrightWire.IDataTable.ForEach(System.Action{BrightWire.IRow,System.Int32})">
            <summary>
            Invokes the callback on each row in the table
            </summary>
            <param name="callback">Callback that is invoked for each row</param>
        </member>
        <member name="M:BrightWire.IDataTable.ForEach(System.Func{BrightWire.IRow,System.Boolean})">
            <summary>
            Invokes the callback on each row in the table
            </summary>
            <param name="callback">Callback that is invoked for each row and returns true to continue processing</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetSlice(System.Int32,System.Int32)">
            <summary>
            Gets a list of rows
            </summary>
            <param name="offset">The first row index</param>
            <param name="count">The number of rows to query</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetRows(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Gets a list of rows
            </summary>
            <param name="rowIndex">A sequence of row indices</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetRows(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets a list of rows
            </summary>
            <param name="rowIndex">A sequence of row indices</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetRow(System.Int32)">
            <summary>
            Returns the row at the specified index
            </summary>
            <param name="rowIndex">The row index to retrieve</param>
        </member>
        <member name="M:BrightWire.IDataTable.Split(System.Nullable{System.Int32},System.Double,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            Splits the table into two random tables
            </summary>
            <param name="randomSeed">Optional random seed</param>
            <param name="trainingPercentage">The size of the training table (expressed as a value between 0 and 1)</param>
            <param name="shuffle">True to shuffle the table before splitting</param>
            <param name="output1">Optional stream to write the first output table to</param>
            <param name="output2">Optional stream to write the second output table to</param>
        </member>
        <member name="M:BrightWire.IDataTable.Normalise(BrightWire.NormalisationType,System.IO.Stream,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a normalised version of the current table
            </summary>
            <param name="normalisationType">The type of normalisation to apply</param>
            <param name="output">Optional stream to write the normalised table to</param>
            <param name="columnIndices">Optional list of column indices to normalise</param>
        </member>
        <member name="M:BrightWire.IDataTable.Normalise(BrightWire.Models.DataTable.DataTableNormalisation,System.IO.Stream)">
            <summary>
            Creates a normalised version of the current table
            </summary>
            <param name="normalisationModel">The normalisation model to apply</param>
            <param name="output">Optional stream to write the normalised table to</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetNormalisationModel(BrightWire.NormalisationType,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Builds a normalisation model from the table that can be used to normalise data to the same scale
            </summary>
            <param name="normalisationType">The type of normalisation</param>
            <param name="columnIndices">Optional list of column indices to normalise</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetColumn``1(System.Int32)">
            <summary>
            Gets a column from the table
            </summary>
            <typeparam name="T">The type to convert the data to</typeparam>
            <param name="columnIndex">The column to retrieve</param>
        </member>
        <member name="M:BrightWire.IDataTable.Bag(System.Nullable{System.Int32},System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Creates a new data table with bagged rows from the current table
            </summary>
            <param name="count">The count of rows to bag</param>
            <param name="output">Optional stream to write the new table to</param>
            <param name="randomSeed">Optional random seed</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.GetNumericRows(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Converts rows to lists of floats
            </summary>
            <param name="columns">Optional list of columns to convert (or null for all columns)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.GetNumericColumns(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets each specified column (or all columns) as an array of floats
            </summary>
            <param name="columns">The columns to return (or null for all)</param>
        </member>
        <member name="M:BrightWire.IDataTable.Classify(BrightWire.IRowClassifier,System.Action{System.Single})">
            <summary>
            Classifies each row
            </summary>
            <param name="classifier">The classifier to use</param>
            <param name="progress">Optional callback that is notified about classification progress</param>
        </member>
        <member name="M:BrightWire.IDataTable.SelectColumns(System.Collections.Generic.IEnumerable{System.Int32},System.IO.Stream)">
            <summary>
            Creates a new data table with the specified columns
            </summary>
            <param name="columns">The columns to include in the new table</param>
            <param name="output">Optional stream to write the new table to</param>
        </member>
        <member name="M:BrightWire.IDataTable.Project(System.Func{BrightWire.IRow,System.Collections.Generic.IReadOnlyList{System.Object}},System.IO.Stream)">
            <summary>
            Creates a new data table with a projection of each existing row
            </summary>
            <param name="mutator">Function that mutates each row into the new format</param>
            <param name="output">Optional stream to write the new table to</param>
            <returns>New table data</returns>
        </member>
        <member name="M:BrightWire.IDataTable.Filter(System.Func{BrightWire.IRow,System.Boolean},System.IO.Stream)">
            <summary>
            Creates a new data table with only those rows that match the specified filter
            </summary>
            <param name="filter">Function that filters each row</param>
            <param name="output">Optional stream to write the new table to</param>
            <returns>New table data</returns>
        </member>
        <member name="M:BrightWire.IDataTable.Fold(System.Int32,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Folds the data table into k buckets
            </summary>
            <param name="k">Number of buckets to create</param>
            <param name="randomSeed">Optional random seed</param>
            <param name="shuffle">True to shuffle the table before folding</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.ConvertToBinaryClassification">
            <summary>
            For each classification label - duplicate each data table except for the classification column which is converted to a boolean (true for each matching example)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.Map``1(System.Func{BrightWire.IRow,``0})">
            <summary>
            Mutates each row of the table
            </summary>
            <typeparam name="T">The type returned by the mutator</typeparam>
            <param name="mutator">The function called for each row in the table</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetVectoriser(System.Boolean)">
            <summary>
            Returns an interface that can convert rows in the current table to vectors
            </summary>
            <param name="useTargetColumnIndex">True to separate the target column index into a separate output vector</param>
        </member>
        <member name="M:BrightWire.IDataTable.GetVectoriser(BrightWire.Models.DataTable.DataTableVectorisation)">
            <summary>
            Returns an interface that can convert rows in the current table to vectors
            </summary>
            <param name="model">A serialised model to recreate a previous vectorisation</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.CopyWithRows(System.Collections.Generic.IEnumerable{System.Int32},System.IO.Stream)">
            <summary>
            Returns a copy of the current table
            </summary>
            <param name="rowIndex">The list of rows to copy</param>
            <param name="output">Optional stream to write the new table to</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.Zip(BrightWire.IDataTable,System.IO.Stream)">
            <summary>
            Creates a new data table with each row of this data table zipped with the corresponding row of the other data table
            </summary>
            <param name="dataTable">The data table whose rows are zipped</param>
            <param name="output">Optional stream to write the new table to</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.IDataTable.XmlPreview">
            <summary>
            Returns table meta-data and the top 20 rows of the table as XML
            </summary>
        </member>
        <member name="P:BrightWire.IDataTable.HasCategoricalData">
            <summary>
            Returns true if the data table contains any non-numeric columns
            </summary>
        </member>
        <member name="M:BrightWire.IDataTable.WriteTo(System.IO.Stream)">
            <summary>
            Writes the data table to a stream
            </summary>
            <param name="stream">The stream to write to</param>
        </member>
        <member name="M:BrightWire.IDataTable.WriteIndexTo(System.IO.Stream)">
            <summary>
            Writes the data table's index to a stream
            </summary>
            <param name="stream">The stream to write to</param>
        </member>
        <member name="M:BrightWire.IDataTable.Reduce(System.Func{BrightWire.IRow,System.Single,System.Single},System.Single)">
            <summary>
            Applies a function against each row in the data table to reduce the table to a single value
            </summary>
            <param name="reducer">The function that is applied to each row</param>
            <param name="initialValue">Initial value passed to the function</param>
            <returns>The accumulated value</returns>
        </member>
        <member name="M:BrightWire.IDataTable.Average(System.Func{BrightWire.IRow,System.Single})">
            <summary>
            Finds an average value from applying the reducer to each row of the table
            </summary>
            <param name="reducer">Function that reduces each row to a single value</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTable.ChangeColumnTypes(System.Collections.Generic.Dictionary{System.Int32,BrightWire.IConvertToType},System.Boolean)">
            <summary>
            Returns a new data table with columns converted to new types
            </summary>
            <param name="columnConversion">Dictionary of columns to convert</param>
            <param name="removeInvalidRows">True to remove rows that fail conversion</param>
        </member>
        <member name="M:BrightWire.IDataTable.Summarise(System.Int32,System.IO.Stream,BrightWire.ISummariseRows)">
            <summary>
            Creates a summarised version of the data table
            </summary>
            <param name="newRowCount">Number of rows to create in the summary table</param>
            <param name="output">Optional stream to write the new table to</param>
            <param name="summariser">A row summariser that will summarise groups of rows (optional)</param>
        </member>
        <member name="T:BrightWire.IRowProcessor">
            <summary>
            Row processor
            </summary>
        </member>
        <member name="M:BrightWire.IRowProcessor.Process(BrightWire.IRow)">
            <summary>
            Will be called for each row
            </summary>
            <param name="row">The current row</param>
            <returns>False to stop</returns>
        </member>
        <member name="T:BrightWire.ColumnInfoType">
            <summary>
            The type of column information
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.String">
            <summary>
            String information (IStringColumnInfo)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.Numeric">
            <summary>
            Numeric information (INumericColumnInfo)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.Date">
            <summary>
            Date information (IDateColumnInfo)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.Frequency">
            <summary>
            Frequency information (IFrequencyColumnInfo)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.Index">
            <summary>
            Index information (IIndexColumnInfo)
            </summary>
        </member>
        <member name="F:BrightWire.ColumnInfoType.Dimensions">
            <summary>
            Dimensions information (IDimensionsColumnInfo)
            </summary>
        </member>
        <member name="T:BrightWire.IColumnInfo">
            <summary>
            Column statistics within a data table
            </summary>
        </member>
        <member name="P:BrightWire.IColumnInfo.ColumnIndex">
            <summary>
            The index of the column in the data table
            </summary>
        </member>
        <member name="P:BrightWire.IColumnInfo.DistinctValues">
            <summary>
            The distinct values within the column
            </summary>
        </member>
        <member name="P:BrightWire.IColumnInfo.NumDistinct">
            <summary>
            The number of distinct values (or null if there are too many)
            </summary>
        </member>
        <member name="P:BrightWire.IColumnInfo.Type">
            <summary>
            The type of column information
            </summary>
        </member>
        <member name="T:BrightWire.IStringColumnInfo">
            <summary>
            Column statistics for a string based column
            </summary>
        </member>
        <member name="P:BrightWire.IStringColumnInfo.MinLength">
            <summary>
            The minimum string length
            </summary>
        </member>
        <member name="P:BrightWire.IStringColumnInfo.MaxLength">
            <summary>
            The maximum string length
            </summary>
        </member>
        <member name="P:BrightWire.IStringColumnInfo.MostCommonString">
            <summary>
            The most common string
            </summary>
        </member>
        <member name="T:BrightWire.IIndexColumnInfo">
            <summary>
            Column statistics for index based columns
            </summary>
        </member>
        <member name="P:BrightWire.IIndexColumnInfo.MinIndex">
            <summary>
            Minimum index
            </summary>
        </member>
        <member name="P:BrightWire.IIndexColumnInfo.MaxIndex">
            <summary>
            Maximum index
            </summary>
        </member>
        <member name="T:BrightWire.INumericColumnInfo">
            <summary>
            Column statistics for a numeric column
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.Min">
            <summary>
            The minimum value
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.Max">
            <summary>
            The maximum value
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.Mean">
            <summary>
            The mean (or average)
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.StdDev">
            <summary>
            The standard deviation
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.Median">
            <summary>
            The median value
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.Mode">
            <summary>
            The mode
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.L1Norm">
            <summary>
            The L1 Norm
            </summary>
        </member>
        <member name="P:BrightWire.INumericColumnInfo.L2Norm">
            <summary>
            The L2 Norm
            </summary>
        </member>
        <member name="T:BrightWire.IDataTableAnalysis">
            <summary>
            Data table statistics
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableAnalysis.ColumnInfo">
            <summary>
            List of column statistics
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableAnalysis.Item(System.Int32)">
            <summary>
            Gets the statistics for a particular column
            </summary>
            <param name="columnIndex">The column index to query</param>
        </member>
        <member name="P:BrightWire.IDataTableAnalysis.ColumnFrequency">
            <summary>
            Column frequency information (only if frequency collection was requested)
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableAnalysis.AsXml">
            <summary>
            Returns a summary of the table analysis
            </summary>
        </member>
        <member name="T:BrightWire.IDataTableColumnFrequency">
            <summary>
            Column data frequency information
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableColumnFrequency.ColumnIndex">
            <summary>
            The index of the column in the data table
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableColumnFrequency.CategoricalFrequency">
            <summary>
            Count of each category (if the column is categorical or null otherwise)
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableColumnFrequency.ContinuousFrequency">
            <summary>
            The bins and the count of each (if the column is continuous or null otherwise)
            </summary>
        </member>
        <member name="T:BrightWire.IDataTableBuilder">
            <summary>
            Used to programatically construct data tables
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableBuilder.Columns">
            <summary>
            The list of columns
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableBuilder.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:BrightWire.IDataTableBuilder.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.AddColumn(BrightWire.ColumnType,System.String,System.Boolean)">
            <summary>
            Adds a new column to the data table
            </summary>
            <param name="column">The data type of the new column</param>
            <param name="name">The name of the new column</param>
            <param name="isTarget">True if the column is a classification target</param>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.AddVectorColumn(System.Int32,System.String,System.Boolean)">
            <summary>
            Adds a vector columns to the data table
            </summary>
            <param name="size">The size of each vector</param>
            <param name="name">New column name</param>
            <param name="isTarget">True if the column is a classification target</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.AddMatrixColumn(System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Adds a matrix column to the data table
            </summary>
            <param name="rows">Rows in each matrix</param>
            <param name="columns">Columns in each matrix</param>
            <param name="name">New column name</param>
            <param name="isTarget">True if the column is a classification target</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.AddTensorColumn(System.Int32,System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Adds a 3D tensor column to the data table
            </summary>
            <param name="rows">Rows in each tensor</param>
            <param name="columns">Columns in each tensor</param>
            <param name="depth">Depth of each tensor</param>
            <param name="name">New column name</param>
            <param name="isTarget">True if the column is a classification target</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.Add(System.Object[])">
            <summary>
            Adds a new row to the table
            </summary>
            <param name="data">The data in the new row</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.Add(System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            Adds a new row to the table
            </summary>
            <param name="data">The data in the new row</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.Build">
            <summary>
            Creates the new data table
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.Flush">
            <summary>
            Ensures all data has been written
            </summary>
        </member>
        <member name="M:BrightWire.IDataTableBuilder.WriteIndexTo(System.IO.Stream)">
            <summary>
            Writes the index data to the specified stream
            </summary>
            <param name="stream">The stream to hold the index data</param>
        </member>
        <member name="T:BrightWire.IConvertToType">
            <summary>
            Interface to convert between types
            </summary>
        </member>
        <member name="M:BrightWire.IConvertToType.ConvertValue(System.Object)">
            <summary>
            Converts an object from one type to another
            </summary>
            <param name="value">The value to convert</param>
            <returns>A tuple of (object</returns>
        </member>
        <member name="T:BrightWire.ISummariseRows">
            <summary>
            Summarises multiple rows into one row
            </summary>
        </member>
        <member name="M:BrightWire.ISummariseRows.Summarise(System.Collections.Generic.IReadOnlyList{BrightWire.IRow})">
            <summary>
            Summarises multiple rows into one row
            </summary>
            <param name="rows">List of rows</param>
            <returns>A single summarised row</returns>
        </member>
        <member name="T:BrightWire.IGraphData">
            <summary>
            Wrapper around the data that is used as a signal between nodes in the graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Rows">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Columns">
            <summary>
            Column count
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Depth">
            <summary>
            3D Tensor depth (1 if the signal is a matrix)
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Count">
            <summary>
            Count of 3D tensors (1 of the signal is a matrix or 3D tensor)
            </summary>
        </member>
        <member name="M:BrightWire.IGraphData.GetMatrix">
            <summary>
            Gets the signal as a matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphData.Get4DTensor">
            <summary>
            Gets the signal as a 4D tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphData.ReplaceWith(BrightWire.IMatrix)">
            <summary>
            Replaces the data with the specified matrix (but preserves any tensor meta data)
            </summary>
            <param name="matrix">The matrix to use as a replacement</param>
        </member>
        <member name="M:BrightWire.IGraphData.GetSubMatrices">
            <summary>
            Returns the list of matrices that compose the signal (single item if the signal is a matrix)
            </summary>
        </member>
        <member name="T:BrightWire.IAction">
            <summary>
            An action to perform when a signal reaches a node
            </summary>
        </member>
        <member name="M:BrightWire.IAction.Execute(BrightWire.IGraphData,BrightWire.IContext)">
            <summary>
            Executes the action
            </summary>
            <param name="input">Current graph signal</param>
            <param name="context">Graph context</param>
            <returns>Optional new graph signal to propagate</returns>
        </member>
        <member name="M:BrightWire.IAction.Serialise">
            <summary>
            Serialises the action to a string
            </summary>
        </member>
        <member name="M:BrightWire.IAction.Initialise(System.String)">
            <summary>
            Initialises the action
            </summary>
            <param name="data">Previously serialised data</param>
        </member>
        <member name="T:BrightWire.ICanInitialiseNode">
            <summary>
            Interface that allows the node to be initialised
            </summary>
        </member>
        <member name="M:BrightWire.ICanInitialiseNode.Initialise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.String,System.String,System.Byte[])">
            <summary>
            Initialise the node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="id">Node unique id</param>
            <param name="name">Friendly name</param>
            <param name="description">Node description</param>
            <param name="data">Serialisation data</param>
        </member>
        <member name="T:BrightWire.ICanSerialise">
            <summary>
            Serialisation interface for graph components
            </summary>
        </member>
        <member name="M:BrightWire.ICanSerialise.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the node state to the binary writer
            </summary>
        </member>
        <member name="M:BrightWire.ICanSerialise.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Reads the node state
            </summary>
            <param name="factory">Graph factory</param>
            <param name="reader">Binary reader that holds the node's state</param>
        </member>
        <member name="T:BrightWire.INode">
            <summary>
            Graph node
            </summary>
        </member>
        <member name="P:BrightWire.INode.Id">
            <summary>
            Unique id
            </summary>
        </member>
        <member name="P:BrightWire.INode.Name">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="P:BrightWire.INode.Output">
            <summary>
            List of outgoing wires
            </summary>
        </member>
        <member name="M:BrightWire.INode.ExecuteForward(BrightWire.IContext,System.Int32)">
            <summary>
            Executes the node forward
            </summary>
            <param name="context">Graph context</param>
            <param name="channel">Channel the signal was received on</param>
        </member>
        <member name="M:BrightWire.INode.FindByName(System.String)">
            <summary>
            Searches for a node by friendly name
            </summary>
            <param name="name">Friendly name of the node to find</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.INode.FindById(System.String)">
            <summary>
            Searches for a node by id
            </summary>
            <param name="id">Unique id of the node</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.INode.SubNodes">
            <summary>
            Sub-nodes of the current node
            </summary>
        </member>
        <member name="M:BrightWire.INode.SerialiseTo(System.Collections.Generic.HashSet{BrightWire.INode},System.Collections.Generic.List{BrightWire.Models.ExecutionGraph.Node},System.Collections.Generic.HashSet{BrightWire.Models.ExecutionGraph.Wire})">
            <summary>
            Serialise the node
            </summary>
            <param name="existing">Set of nodes that have already been serialised in the current context</param>
            <param name="connectedTo">List of nodes this node is connected to</param>
            <param name="wireList">List of wires between all connected nodes</param>
            <returns>Serialisation model</returns>
        </member>
        <member name="M:BrightWire.INode.OnDeserialise(System.Collections.Generic.IReadOnlyDictionary{System.String,BrightWire.INode})">
            <summary>
            Called after the graph has been completely deserialised
            </summary>
            <param name="graph">Dictionary of nodes with their associated unique ids</param>
        </member>
        <member name="M:BrightWire.INode.LoadParameters(BrightWire.Models.ExecutionGraph.Node)">
            <summary>
            Loads parameters into an existing node
            </summary>
            <param name="nodeData">Serialised node parameters</param>
        </member>
        <member name="T:BrightWire.IWire">
            <summary>
            Wires connect nodes in the graph
            </summary>
        </member>
        <member name="P:BrightWire.IWire.SendTo">
            <summary>
            The node to send a signal to
            </summary>
        </member>
        <member name="P:BrightWire.IWire.Channel">
            <summary>
            The channel
            </summary>
        </member>
        <member name="T:BrightWire.IExecutionHistory">
            <summary>
            Record of node execution
            </summary>
        </member>
        <member name="P:BrightWire.IExecutionHistory.Source">
            <summary>
            Node that was executed
            </summary>
        </member>
        <member name="P:BrightWire.IExecutionHistory.Parents">
            <summary>
            The node's parents
            </summary>
        </member>
        <member name="P:BrightWire.IExecutionHistory.Data">
            <summary>
            Node output signal
            </summary>
        </member>
        <member name="P:BrightWire.IExecutionHistory.Backpropagation">
            <summary>
            Optional backpropagation
            </summary>
        </member>
        <member name="T:BrightWire.IContext">
            <summary>
            Graph context
            </summary>
        </member>
        <member name="P:BrightWire.IContext.IsTraining">
            <summary>
            True if the graph is currently training
            </summary>
        </member>
        <member name="P:BrightWire.IContext.Source">
            <summary>
            Node that sent the current signal
            </summary>
        </member>
        <member name="P:BrightWire.IContext.Data">
            <summary>
            Current signal
            </summary>
        </member>
        <member name="P:BrightWire.IContext.ExecutionContext">
            <summary>
            Current execution context
            </summary>
        </member>
        <member name="P:BrightWire.IContext.LearningContext">
            <summary>
            Current learning context (optional)
            </summary>
        </member>
        <member name="P:BrightWire.IContext.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightWire.IContext.BatchSequence">
            <summary>
            Current mini batch sequence
            </summary>
        </member>
        <member name="M:BrightWire.IContext.AddForward(BrightWire.IExecutionHistory,System.Func{BrightWire.IBackpropagation})">
            <summary>
            Records node execution
            </summary>
            <param name="action">Record of node execution</param>
            <param name="callback">Optional callback to add backpropagation</param>
        </member>
        <member name="M:BrightWire.IContext.AddBackward(BrightWire.IGraphData,BrightWire.INode,BrightWire.INode)">
            <summary>
            Sends a backward error signal
            </summary>
            <param name="errorSignal">Error signal</param>
            <param name="target">Node to send to</param>
            <param name="source">Node that sent the error</param>
        </member>
        <member name="M:BrightWire.IContext.AppendErrorSignal(BrightWire.IGraphData,BrightWire.INode)">
            <summary>
            Records an error signal against a node
            </summary>
            <param name="errorSignal">Error signal</param>
            <param name="forNode">Node to record against</param>
        </member>
        <member name="M:BrightWire.IContext.Backpropagate(BrightWire.IGraphData)">
            <summary>
            Backpropagates the signal
            </summary>
            <param name="delta">Error signal</param>
        </member>
        <member name="P:BrightWire.IContext.ErrorSignal">
            <summary>
            Current error signal
            </summary>
        </member>
        <member name="P:BrightWire.IContext.HasNext">
            <summary>
            Checks if there is a pending forward graph operation
            </summary>
        </member>
        <member name="M:BrightWire.IContext.ExecuteNext">
            <summary>
            Executes the next pending forward graph operation
            </summary>
            <returns>True if an operation was executed</returns>
        </member>
        <member name="M:BrightWire.IContext.SetOutput(BrightWire.IGraphData,System.Int32)">
            <summary>
            Saves the data as an output of the graph
            </summary>
            <param name="data">Data to save</param>
            <param name="channel">Channel to save against (optional)</param>
        </member>
        <member name="M:BrightWire.IContext.GetOutput(System.Int32)">
            <summary>
            Returns a saved output
            </summary>
            <param name="channel">Output channel (optional)</param>
        </member>
        <member name="P:BrightWire.IContext.Output">
            <summary>
            Returns all stored output
            </summary>
        </member>
        <member name="T:BrightWire.IExecutionContext">
            <summary>
            Graph execution context
            </summary>
        </member>
        <member name="M:BrightWire.IExecutionContext.SetMemory(System.String,BrightWire.IMatrix)">
            <summary>
            Writes to a named memory slot
            </summary>
            <param name="slotName">Slot name</param>
            <param name="memory">Data</param>
        </member>
        <member name="M:BrightWire.IExecutionContext.GetMemory(System.String)">
            <summary>
            Reads from a named memory slot
            </summary>
            <param name="slotName">Slot name</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IExecutionContext.GetNextOperation">
            <summary>
            Gets the next queued graph operation (if any)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IExecutionContext.Add(System.Collections.Generic.IReadOnlyList{BrightWire.IGraphOperation})">
            <summary>
            Adds a list of graph operations to the queue
            </summary>
            <param name="operationList">List of operations</param>
        </member>
        <member name="P:BrightWire.IExecutionContext.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightWire.IExecutionContext.RemainingOperationCount">
            <summary>
            How many operations remain queued
            </summary>
        </member>
        <member name="M:BrightWire.IExecutionContext.RegisterContinuation(BrightWire.IMiniBatchSequence,System.Action{BrightWire.IContext})">
            <summary>
            Registers a continuation that will be executed after the current sequence has been processed in full
            </summary>
            <param name="sequence">Sequence index</param>
            <param name="callback">Continuation</param>
        </member>
        <member name="P:BrightWire.IExecutionContext.HasContinuations">
            <summary>
            True if there are registered continuations
            </summary>
        </member>
        <member name="M:BrightWire.IExecutionContext.Continue(BrightWire.IContext)">
            <summary>
            Execute any registered continuation for this context
            </summary>
            <param name="context">Context with an associated IMiniBatchSequence</param>
        </member>
        <member name="T:BrightWire.IBackpropagation">
            <summary>
            Backpropagation handler
            </summary>
        </member>
        <member name="M:BrightWire.IBackpropagation.Backward(BrightWire.INode,BrightWire.IGraphData,BrightWire.IContext,System.Collections.Generic.IReadOnlyList{BrightWire.INode})">
            <summary>
            Backpropagate
            </summary>
            <param name="fromNode">Node that sent the signal</param>
            <param name="errorSignal">Error signal</param>
            <param name="context">Graph context</param>
            <param name="parents">The current node's parents</param>
        </member>
        <member name="T:BrightWire.IDataSource">
            <summary>
            Data sources feed data into a graph
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.IsSequential">
            <summary>
            True if the data is sequential
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.InputSize">
            <summary>
            The size of the input data
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.OutputSize">
            <summary>
            The size of the output data
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.InputCount">
            <summary>
            The number of inputs that can feed into the graph
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="M:BrightWire.IDataSource.Get(BrightWire.IExecutionContext,System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Gets a mini batch with the specified rows
            </summary>
            <param name="executionContext">Graph execution context</param>
            <param name="rows">List of rows</param>
        </member>
        <member name="M:BrightWire.IDataSource.GetBuckets">
            <summary>
            For sequential data, returns the row indexes grouped by sequence length
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataSource.OnBatchProcessed(BrightWire.IContext)">
            <summary>
            Called when the current batch has completed
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:BrightWire.IDataSource.CloneWith(BrightWire.IDataTable)">
            <summary>
            Creates a new data source, using the current as a template but replacing the data table
            </summary>
            <param name="dataTable">The new data table</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IAdaptiveDataSource">
            <summary>
            Adaptive data sources apply the output from a preliminary graph
            </summary>
        </member>
        <member name="P:BrightWire.IAdaptiveDataSource.AdaptiveInput">
            <summary>
            The input node of the preliminary graph
            </summary>
        </member>
        <member name="M:BrightWire.IAdaptiveDataSource.GetModel(System.String)">
            <summary>
            Gets the serialised preliminary graph
            </summary>
            <param name="name">Optional name to give the data source</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.MiniBatchSequenceType">
            <summary>
            Mini batch type
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.Standard">
            <summary>
            Standard batch type (non sequential batches have a single standard sequence item)
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.SequenceStart">
            <summary>
            Start of a sequence
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.SequenceEnd">
            <summary>
            End of a sequence
            </summary>
        </member>
        <member name="T:BrightWire.IMiniBatchSequence">
            <summary>
            A sequence within a mini batch
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatchSequence.MiniBatch">
            <summary>
            Mini batch
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatchSequence.SequenceIndex">
            <summary>
            Index of the sequence
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatchSequence.Type">
            <summary>
            Sequence type
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatchSequence.Input">
            <summary>
            Input data
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatchSequence.Target">
            <summary>
            Training target data
            </summary>
        </member>
        <member name="T:BrightWire.IMiniBatch">
            <summary>
            Information about the current mini batch
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.Rows">
            <summary>
            Row indexes of the current batch
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.DataSource">
            <summary>
            Data source
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.IsSequential">
            <summary>
            True if the data is sequential
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.BatchSize">
            <summary>
            Number of items in the batch
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.CurrentSequence">
            <summary>
            Current sequence (non sequential batches have a single sequence)
            </summary>
        </member>
        <member name="P:BrightWire.IMiniBatch.HasNextSequence">
            <summary>
            True if there is another item in the sequence after the current item
            </summary>
        </member>
        <member name="M:BrightWire.IMiniBatch.GetNextSequence">
            <summary>
            Gets the next item in the sequence
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightWire.IMiniBatch.SequenceCount">
            <summary>
            Gets the length of the sequence
            </summary>
        </member>
        <member name="M:BrightWire.IMiniBatch.GetSequenceAtIndex(System.Int32)">
            <summary>
            Gets a sequence item
            </summary>
            <param name="index">The index to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IMiniBatch.Reset">
            <summary>
            Resets the sequence iterator
            </summary>
        </member>
        <member name="T:BrightWire.IGraphOperation">
            <summary>
            A pending graph operation (mini batch)
            </summary>
        </member>
        <member name="M:BrightWire.IGraphOperation.Execute(BrightWire.IExecutionContext)">
            <summary>
            Executes the operation
            </summary>
            <param name="executionContext">Graph execution context</param>
        </member>
        <member name="T:BrightWire.IGraphEngine">
            <summary>
            Graph engines drive execution within a graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.Graph">
            <summary>
            Serialised version of the current graph and its parameters
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.DataSource">
            <summary>
            Data source that feeds into the graph
            </summary>
        </member>
        <member name="M:BrightWire.IGraphEngine.Execute(BrightWire.IDataSource,System.Int32,System.Action{System.Single})">
            <summary>
            Executes a data source on the current graph
            </summary>
            <param name="dataSource">Data source to process</param>
            <param name="batchSize">Initial size of each mini batch</param>
            <param name="batchCompleteCallback">Optional callback to be notifiied after each mini batch has completed</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphEngine.Execute(System.Single[])">
            <summary>
            Executes a single vector on the current graph
            </summary>
            <param name="input">Vector to execute</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphEngine.ExecuteSequential(System.Int32,System.Single[],BrightWire.IExecutionContext,BrightWire.MiniBatchSequenceType)">
            <summary>
            Executes a sequential input on the current graph
            </summary>
            <param name="sequenceIndex">Index of the current sequence (starting from 0)</param>
            <param name="input">Input vector</param>
            <param name="executionContext">Graph execution context</param>
            <param name="sequenceType">The sequence type (start, standard, end)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphEngine.ExecuteSequential(System.Collections.Generic.IReadOnlyList{System.Single[]})">
            <summary>
            Executes a sequence of inputs on the current graph
            </summary>
            <param name="input">List of vector inputs</param>
            <returns>List of execution results</returns>
        </member>
        <member name="P:BrightWire.IGraphEngine.Start">
            <summary>
            The graph's single start node
            </summary>
        </member>
        <member name="T:BrightWire.IGraphTrainingEngine">
            <summary>
            A graph engine that also trains the graph's parameters against training data
            </summary>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.GetInput(System.Int32)">
            <summary>
            Returns the specified input node
            </summary>
            <param name="index">Index of the input node to retrieve</param>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.Train(BrightWire.IExecutionContext,System.Action{System.Single})">
            <summary>
            Executes a training epoch on the graph
            </summary>
            <param name="executionContext">Graph execution context</param>
            <param name="batchCompleteCallback">Optional callback to be notifiied after each mini batch has completed</param>
            <returns>Graph training error</returns>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.Test(BrightWire.IDataSource,BrightWire.IErrorMetric,System.Int32,System.Action{System.Single},System.Action{System.Single,System.Double,System.Boolean,System.Boolean})">
            <summary>
            Executes test data on the current graph
            </summary>
            <param name="testDataSource">Data source with test data</param>
            <param name="errorMetric">Error metric to use to evaluate the test score</param>
            <param name="batchSize">Initial size of each mini batch</param>
            <param name="batchCompleteCallback">Optional callback to be notifiied after each mini batch has completed</param>
            <param name="values">Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data</param>
            <returns>True if the model performance has improved since the last test</returns>
        </member>
        <member name="P:BrightWire.IGraphTrainingEngine.LearningContext">
            <summary>
            Graph learning context
            </summary>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.LoadParametersFrom(BrightWire.Models.ExecutionGraph)">
            <summary>
            Loads model parameters into the existing graph
            </summary>
            <param name="graph">Model to load parameters from</param>
        </member>
        <member name="T:BrightWire.IHaveMemoryNode">
            <summary>
            Nodes that have a memory feeder sub-node
            </summary>
        </member>
        <member name="P:BrightWire.IHaveMemoryNode.Memory">
            <summary>
            The memory feed sub node
            </summary>
        </member>
        <member name="T:BrightWire.IMemoryNode">
            <summary>
            Recurrent neural networks memory node
            </summary>
        </member>
        <member name="P:BrightWire.IMemoryNode.Data">
            <summary>
            The current state of the memory node
            </summary>
        </member>
        <member name="T:BrightWire.IFeedForward">
            <summary>
            Feed forward layer
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.InputSize">
            <summary>
            Size of incoming connections
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.OutputSize">
            <summary>
            Size of outgoing connections
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.Bias">
            <summary>
            Bias vector
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.Weight">
            <summary>
            Weight matrix
            </summary>
        </member>
        <member name="M:BrightWire.IFeedForward.UpdateWeights(BrightWire.IMatrix,BrightWire.ILearningContext)">
            <summary>
            Updates the weights
            </summary>
            <param name="delta">Weight delta matrix</param>
            <param name="context">Graph learning context</param>
        </member>
        <member name="T:BrightWire.IHaveAction">
            <summary>
            Node that exposes an action
            </summary>
        </member>
        <member name="P:BrightWire.IHaveAction.Action">
            <summary>
            The node's action
            </summary>
        </member>
        <member name="T:BrightWire.IVolumeDataSource">
            <summary>
            Volume (3D tensor) based data sources
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Width">
            <summary>
            Width of each input volume
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Height">
            <summary>
            Height of each input volume
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Depth">
            <summary>
            Depth of each input volume
            </summary>
        </member>
        <member name="T:BrightWire.IGpuLinearAlgebraProvider">
            <summary>
            Helper methods when using the GPU linear algebra provider
            </summary>
        </member>
        <member name="M:BrightWire.IGpuLinearAlgebraProvider.BindThread">
            <summary>
            Binds the current thread to the cuda context (when using the same cuda provider from multiple threads)
            </summary>
        </member>
        <member name="P:BrightWire.IGpuLinearAlgebraProvider.FreeMemory">
            <summary>
            Amount of free memory on the device in bytes
            </summary>
        </member>
        <member name="P:BrightWire.IGpuLinearAlgebraProvider.TotalMemory">
            <summary>
            Amount of total memory on the device in bytes
            </summary>
        </member>
        <member name="T:BrightWire.ILinearAlgebraProvider">
            <summary>
            Provides linear algebra functionality
            </summary>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateVector(System.Int32,System.Boolean)">
            <summary>
            Creates a new vector
            </summary>
            <param name="length">Length of the vector</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateVector(System.Int32,System.Func{System.Int32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="length">Size of the vector</param>
            <param name="init">Callback to initialise each element of the vector</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateMatrix(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a matrix
            </summary>
            <param name="rows">The number of rows</param>
            <param name="columns">The number of columns</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateMatrix(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="rows">The number of rows</param>
            <param name="columns">The number of columns</param>
            <param name="init">Callback to initialise each element of the matrix</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateMatrixFromRows(System.Collections.Generic.IReadOnlyList{BrightWire.IVector})">
            <summary>
            Creates a matrix from a list of vectors. Each vector will become a row in the new matrix
            </summary>
            <param name="vectorRows">List of vectors for each row</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CreateMatrixFromColumns(System.Collections.Generic.IReadOnlyList{BrightWire.IVector})">
            <summary>
            Creates a matrix from a list of vectors. Each vector will become a column in the new matrix
            </summary>
            <param name="vectorColumns">List of vectors for each column</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.Create3DTensor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="depth">Number of depth slices</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.Create3DTensor(System.Collections.Generic.IReadOnlyList{BrightWire.IMatrix})">
            <summary>
            Creates a 3D tensor from a list of matrices
            </summary>
            <param name="matrices">List of matrices</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.Create4DTensor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="depth">Number of matrices</param>
            <param name="count">Number of 3D tensors</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.Create4DTensor(System.Collections.Generic.IReadOnlyList{BrightWire.I3DTensor})">
            <summary>
            Creates a 4D tensor from a list of 3D tensors
            </summary>
            <param name="tensors">List of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.Create4DTensor(System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatTensor})">
            <summary>
            Creates a 4D tensor from a list of 3D tensors
            </summary>
            <param name="tensors">List of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.PushLayer">
            <summary>
            Creates a save point in the allocation history
            </summary>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.PopLayer">
            <summary>
            Releases all allocated memory since the last save point
            </summary>
        </member>
        <member name="P:BrightWire.ILinearAlgebraProvider.IsStochastic">
            <summary>
            Underlying setting for stochastic vs deterministic behaviour for instances created from this provider
            </summary>
        </member>
        <member name="P:BrightWire.ILinearAlgebraProvider.IsGpu">
            <summary>
            True if the provider uses the GPU
            </summary>
        </member>
        <member name="M:BrightWire.ILinearAlgebraProvider.CalculateDistances(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},System.Collections.Generic.IReadOnlyList{BrightWire.IVector},BrightWire.DistanceMetric)">
            <summary>
            Calculates the distance of each vector against the comparison vectors - the size of all vectors should be the same
            </summary>
            <param name="vectors"></param>
            <param name="comparison"></param>
            <param name="distanceMetric"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.DistanceMetric">
            <summary>
            Distance metrics
            </summary>
        </member>
        <member name="F:BrightWire.DistanceMetric.Euclidean">
            <summary>
            Euclidean Distance
            </summary>
        </member>
        <member name="F:BrightWire.DistanceMetric.Cosine">
            <summary>
            Cosine Distance Metric
            </summary>
        </member>
        <member name="F:BrightWire.DistanceMetric.Manhattan">
            <summary>
            Manhattan Distance
            </summary>
        </member>
        <member name="F:BrightWire.DistanceMetric.MeanSquared">
            <summary>
            Means Square Error
            </summary>
        </member>
        <member name="F:BrightWire.DistanceMetric.SquaredEuclidean">
            <summary>
            Square Euclidean
            </summary>
        </member>
        <member name="T:BrightWire.IVector">
            <summary>
            A vector
            </summary>
        </member>
        <member name="P:BrightWire.IVector.IsValid">
            <summary>
            Checks if the vector has not been disposed
            </summary>
        </member>
        <member name="M:BrightWire.IVector.ReshapeAsColumnMatrix">
            <summary>
            Converts the vector to a column matrix
            </summary>
        </member>
        <member name="M:BrightWire.IVector.ReshapeAsRowMatrix">
            <summary>
            Converts the vector to a row matrix
            </summary>
        </member>
        <member name="P:BrightWire.IVector.Count">
            <summary>
            The number of elements in the vector
            </summary>
        </member>
        <member name="P:BrightWire.IVector.Data">
            <summary>
            Converts the vector into protobuf format
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Add(BrightWire.IVector)">
            <summary>
            Adds a vector (without in place modification)
            </summary>
            <param name="vector">The vector to add</param>
        </member>
        <member name="M:BrightWire.IVector.Subtract(BrightWire.IVector)">
            <summary>
            Subtracts a vector (without in place modification)
            </summary>
            <param name="vector">The vector to subtract</param>
        </member>
        <member name="M:BrightWire.IVector.L1Norm">
            <summary>
            Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)
            </summary>
        </member>
        <member name="M:BrightWire.IVector.L2Norm">
            <summary>
            Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)
            </summary>
        </member>
        <member name="M:BrightWire.IVector.MaximumIndex">
            <summary>
            Returns the index of the vector with the greatest value
            </summary>
        </member>
        <member name="M:BrightWire.IVector.MinimumIndex">
            <summary>
            Returns the index of the vector with the smallest value
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Multiply(System.Single)">
            <summary>
            Multiples (in place) by a scalar
            </summary>
            <param name="scalar">The value to multiple each element</param>
        </member>
        <member name="M:BrightWire.IVector.Add(System.Single)">
            <summary>
            Adds (in place) a scalar
            </summary>
            <param name="scalar">The value to add to each element</param>
        </member>
        <member name="M:BrightWire.IVector.AddInPlace(BrightWire.IVector,System.Single,System.Single)">
            <summary>
            Adds a vector in place
            </summary>
            <param name="vector">The target vector to add to the current vector</param>
            <param name="coefficient1">A value to multiply each element of the current vector</param>
            <param name="coefficient2">A value to multiply each element of the target vector</param>
        </member>
        <member name="M:BrightWire.IVector.SubtractInPlace(BrightWire.IVector,System.Single,System.Single)">
            <summary>
            Subtracts a vector in place
            </summary>
            <param name="vector">The target vector to subtract from the current vector</param>
            <param name="coefficient1">A value to multiply each element of the current vector</param>
            <param name="coefficient2">A value to multiply each element of the target vector</param>
        </member>
        <member name="M:BrightWire.IVector.AsIndexable">
            <summary>
            Converts the vector to an indexable vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.PointwiseMultiply(BrightWire.IVector)">
            <summary>
            Pointwise multiplication (without in place modification) with a vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.DotProduct(BrightWire.IVector)">
            <summary>
            The dot product of two vectors
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IVector.GetNewVectorFromIndexes(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Returns a new vector from a subset of the vector indices
            </summary>
            <param name="indices">A list of indexes to use as the source of the new vector</param>
        </member>
        <member name="M:BrightWire.IVector.Clone">
            <summary>
            Creates a new copy of the vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Sqrt">
            <summary>
            Creates a new vector in which each element is the square root of the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Abs">
            <summary>
            Creates a new vector in which each element is the absolute value of the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.CopyFrom(BrightWire.IVector)">
            <summary>
            Copies values from the target vector into the current vector
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightWire.IVector.EuclideanDistance(BrightWire.IVector)">
            <summary>
            Calculates the euclidean distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IVector.CosineDistance(BrightWire.IVector)">
            <summary>
            Calculates the cosine distance between the current and the target vector
            </summary>
            <param name="vector">The target vector></param>
        </member>
        <member name="M:BrightWire.IVector.ManhattanDistance(BrightWire.IVector)">
            <summary>
            Calculates the manhattan distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IVector.MeanSquaredDistance(BrightWire.IVector)">
            <summary>
            Calculates the mean squared distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IVector.SquaredEuclidean(BrightWire.IVector)">
            <summary>
            Calculates the squared euclidean distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IVector.GetMinMax">
            <summary>
            Finds the minimum and maximum values in the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Average">
            <summary>
            Calculates the average value from the elements of the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.StdDev(System.Nullable{System.Single})">
            <summary>
            Calculates the standard deviation from the elements of the current vector
            </summary>
            <param name="mean">(optional) pre calculated mean</param>
        </member>
        <member name="M:BrightWire.IVector.Normalise(BrightWire.NormalisationType)">
            <summary>
            Normalises (in place) the values of the current vector
            </summary>
            <param name="type">The type of normalisation</param>
        </member>
        <member name="M:BrightWire.IVector.Softmax">
            <summary>
            Returns the softmax function (without in place modification) applied to the current vector
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
        </member>
        <member name="M:BrightWire.IVector.SoftmaxDerivative">
            <summary>
            Returns the jacobian matrix of the softmax derivative
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IVector.FindDistances(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},BrightWire.DistanceMetric)">
            <summary>
            Returns a vector of distances between the current and target vectors
            </summary>
            <param name="data">The list of target vectors</param>
            <param name="distance">The distance metric</param>
            <returns>A vector in which each element n is the distance between the current and the nth target vector</returns>
        </member>
        <member name="M:BrightWire.IVector.FindDistance(BrightWire.IVector,BrightWire.DistanceMetric)">
            <summary>
            Returns the distance between the current and the target vector
            </summary>
            <param name="other">The target vector</param>
            <param name="distance">The distance metric</param>
        </member>
        <member name="M:BrightWire.IVector.CosineDistance(System.Collections.Generic.IReadOnlyList{BrightWire.IVector},System.Single[]@)">
            <summary>
            Returns a vector of the cosine distance between the current and target vectors
            </summary>
            <param name="data">The list of target vectors</param>
            <param name="dataNorm">A buffer to hold the norms of the target vectors</param>
            <returns>A vector in which each element n is the cosine distance between the current and the nth target vector</returns>
        </member>
        <member name="M:BrightWire.IVector.Log">
            <summary>
            Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.Sigmoid">
            <summary>
            Returns the sigmoid function (without in place modification) applied to the current vector
            </summary>
        </member>
        <member name="M:BrightWire.IVector.ReshapeAsMatrix(System.Int32,System.Int32)">
            <summary>
            Fast conversion to matrix (internal buffer is used directly)
            </summary>
            <param name="rows">The number of rows in the matrix</param>
            <param name="columns">The number of columns in the matrix</param>
        </member>
        <member name="M:BrightWire.IVector.ReshapeAs3DTensor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts the vector to a 3D tensor
            </summary>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <param name="depth">Number of matrices</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IVector.ReshapeAs4DTensor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts the vector to a 4D tensor
            </summary>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <param name="depth">Number of matrices</param>
            <param name="count">Number of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IVector.Split(System.Int32)">
            <summary>
            Splits the vector into a list of vectors
            </summary>
            <param name="blockCount">The number of sub vectors to split into</param>
        </member>
        <member name="M:BrightWire.IVector.RotateInPlace(System.Int32)">
            <summary>
            Rotates values in the vector (both horizontally and vertically within blocks)
            </summary>
            <param name="blockCount"></param>
        </member>
        <member name="M:BrightWire.IVector.Reverse">
            <summary>
            Returns a reversed copy of the vector's values
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IVector.GetAt(System.Int32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="index">The index of the vector to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IVector.SetAt(System.Int32,System.Single)">
            <summary>
            Updates the value at the specified index
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:BrightWire.IVector.IsEntirelyFinite">
            <summary>
            Checks if every value in the vector is finite (not NaN or positive/negative infinity)
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IIndexableVector">
            <summary>
            Returns an indexable vector (in which elements can be directly indexed)
            </summary>
        </member>
        <member name="P:BrightWire.IIndexableVector.Item(System.Int32)">
            <summary>
            Returns an element at the specified index
            </summary>
            <param name="index">The index to retrieve</param>
        </member>
        <member name="P:BrightWire.IIndexableVector.Values">
            <summary>
            Gets the values as an enumerable
            </summary>
        </member>
        <member name="M:BrightWire.IIndexableVector.ToArray">
            <summary>
            Converts the vector to an array
            </summary>
        </member>
        <member name="M:BrightWire.IIndexableVector.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the vector as well)
            </summary>
        </member>
        <member name="M:BrightWire.IIndexableVector.Append(System.Collections.Generic.IReadOnlyList{System.Single})">
            <summary>
            Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector
            </summary>
            <param name="data">The values to append</param>
        </member>
        <member name="T:BrightWire.IMatrix">
            <summary>
            A matrix
            </summary>
        </member>
        <member name="P:BrightWire.IMatrix.IsValid">
            <summary>
            Checks if the matrix has not been disposed
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Multiply(BrightWire.IMatrix)">
            <summary>
            Multiplies the current vector (without in place modification) with the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="P:BrightWire.IMatrix.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:BrightWire.IMatrix.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Column(System.Int32)">
            <summary>
            Returns a column as a vector
            </summary>
            <param name="index">The column index</param>
        </member>
        <member name="M:BrightWire.IMatrix.Diagonal">
            <summary>
            Returns the matrix diagonal as a vector
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Row(System.Int32)">
            <summary>
            Returns a row as a vector
            </summary>
            <param name="index">The row index</param>
        </member>
        <member name="M:BrightWire.IMatrix.Add(BrightWire.IMatrix)">
            <summary>
            Returns the current matrix (without in place modification) added to the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.Subtract(BrightWire.IMatrix)">
            <summary>
            Returns the current matrix  (without in place modification) minus the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.PointwiseMultiply(BrightWire.IMatrix)">
            <summary>
            Returns the pointwise product of the current matrix (without in place modification) with the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.TransposeAndMultiply(BrightWire.IMatrix)">
            <summary>
            Returns the current matrix (without in place modification) and multipled with the transposed target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.TransposeThisAndMultiply(BrightWire.IMatrix)">
            <summary>
            Returns the transpose of the current matrix (without in place modification) multipled with the target matrix
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:BrightWire.IMatrix.RowSums">
            <summary>
            Returns a vector that contains the sum of the elements in each row of the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.ColumnSums">
            <summary>
            Returns a vector that contains the sum of the elements in each column of the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Transpose">
            <summary>
            Returns the transpose of the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Multiply(System.Single)">
            <summary>
            Multiplies (in place) each element of the matrix by a scalar
            </summary>
            <param name="scalar">The scalar to multiply each element</param>
        </member>
        <member name="M:BrightWire.IMatrix.Multiply(BrightWire.IVector)">
            <summary>
            Returns the product of the current matrix (without in place modification) with the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IMatrix.AddInPlace(BrightWire.IMatrix,System.Single,System.Single)">
            <summary>
            Adds the target matrix to the current matrix (in place)
            </summary>
            <param name="matrix">The target matrix</param>
            <param name="coefficient1">A coefficient to multiply each element of the current matrix</param>
            <param name="coefficient2">A coefficient to multipy each element of the target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.SubtractInPlace(BrightWire.IMatrix,System.Single,System.Single)">
            <summary>
            Subtracts the target matrix from the current matrix (in place)
            </summary>
            <param name="matrix">The target matrix</param>
            <param name="coefficient1">A coefficient to multiply each element of the current matrix</param>
            <param name="coefficient2">A coefficient to multipy each element of the target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.SigmoidActivation">
            <summary>
            Returns a new matrix with the sigmoid function applied to each element
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.SigmoidDerivative">
            <summary>
            Returns a new matrix with the sigmoid derivative of each element
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.TanhActivation">
            <summary>
            Returns a new matrix with the tanh function applied to each element
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.TanhDerivative">
            <summary>
            Returns a new matrix with the tanh derivative of each element
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.SoftmaxActivation">
            <summary>
            Returns a new matrix with the softmax function applied to each row of the matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.AddToEachRow(BrightWire.IVector)">
            <summary>
            Adds the target vector to each row of the current matrix (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IMatrix.AddToEachColumn(BrightWire.IVector)">
            <summary>
            Adds the target vector to each column of the current matrix (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="P:BrightWire.IMatrix.Data">
            <summary>
            Converts the current matrix to protobuf format
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.AsIndexable">
            <summary>
            Converts the matrix to an indexable matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.GetNewMatrixFromRows(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Returns a new matrix from a subset of the current matrix's rows
            </summary>
            <param name="rowIndexes">The list of row indices</param>
        </member>
        <member name="M:BrightWire.IMatrix.GetNewMatrixFromColumns(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Returns a new matrix from a subset of the current matrix's columns
            </summary>
            <param name="columnIndexes">The list of column indices</param>
        </member>
        <member name="M:BrightWire.IMatrix.ClearRows(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Set to zero the specified rows in the current matrix
            </summary>
            <param name="indexes">The list of row indices</param>
        </member>
        <member name="M:BrightWire.IMatrix.ClearColumns(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Set to zero the specified columns in the current matrix
            </summary>
            <param name="indexes">The list of column indices</param>
        </member>
        <member name="M:BrightWire.IMatrix.ReluActivation">
            <summary>
            Returns the RELU function applied to each element of the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.ReluDerivative">
            <summary>
            Returns the RELU derivative of each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.LeakyReluActivation">
            <summary>
            Returns the leaky RELU function applied to each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.LeakyReluDerivative">
            <summary>
            Returns the leaky RELU derivative of each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Clone">
            <summary>
            Creates a copy of the current matrix
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Clear">
            <summary>
            Sets each element to zero
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.Sqrt(System.Single)">
            <summary>
            Returns the square root of each element in the current matrix
            </summary>
            <param name="valueAdjustment">Term to add to each element in the result matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.Pow(System.Single)">
            <summary>
            Returns each element raised to specified power
            </summary>
            <param name="power">The power to apply to each element</param>
        </member>
        <member name="M:BrightWire.IMatrix.PointwiseDivide(BrightWire.IMatrix)">
            <summary>
            Returns the current matrix (not modified in place) divided by the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.L1Regularisation(System.Single)">
            <summary>
            L1 Regularisation applied to each element of the current matrix (in place)
            </summary>
            <param name="coefficient">The L1 coefficient</param>
        </member>
        <member name="M:BrightWire.IMatrix.ColumnL2Norm">
            <summary>
            Returns a vector of the L2 norms of each column
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.RowL2Norm">
            <summary>
            Returns a vector of the L2 norms of each row
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.PointwiseDivideRows(BrightWire.IVector)">
            <summary>
            Pointwise divide each row by the target vector (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IMatrix.PointwiseDivideColumns(BrightWire.IVector)">
            <summary>
            Pointwise divide each column by the target vector (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightWire.IMatrix.Constrain(System.Single,System.Single)">
            <summary>
            Constrain each value within the specified min and max values (in place)
            </summary>
            <param name="min">The minimum allowed value</param>
            <param name="max">The maximum allowed value</param>
        </member>
        <member name="M:BrightWire.IMatrix.GetRowSegment(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a segment from a row of the current matrix
            </summary>
            <param name="rowIndex">The row index</param>
            <param name="columnIndex">The start index to return</param>
            <param name="length">The number of elements to return</param>
        </member>
        <member name="M:BrightWire.IMatrix.GetColumnSegment(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a segment from a column of the current matrix
            </summary>
            <param name="columnIndex">The column index</param>
            <param name="rowIndex">The start index to return</param>
            <param name="length">The number of elements to return</param>
        </member>
        <member name="M:BrightWire.IMatrix.ConcatColumns(BrightWire.IMatrix)">
            <summary>
            Returns a new matrix with the columns of the target matrix appended to each column of the current matrix
            </summary>
            <param name="bottom">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.ConcatRows(BrightWire.IMatrix)">
            <summary>
            Returns a new matrix with the rows of the target matrix appended to each row of the current matrix
            </summary>
            <param name="right">The target matrix</param>
        </member>
        <member name="M:BrightWire.IMatrix.SplitAtColumn(System.Int32)">
            <summary>
            Splits the rows of the current matrix into two matrices
            </summary>
            <param name="columnIndex">The column index at which to split</param>
        </member>
        <member name="M:BrightWire.IMatrix.SplitAtRow(System.Int32)">
            <summary>
            Splits the columns of the current matrix into two matrices
            </summary>
            <param name="rowIndex">The row index at which to split</param>
        </member>
        <member name="M:BrightWire.IMatrix.Svd">
            <summary>
            Singular value decomposition
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.ReshapeAsVector">
            <summary>
            Fast conversion to vector (the internal buffer is not modified)
            </summary>
        </member>
        <member name="M:BrightWire.IMatrix.ReshapeAs3DTensor(System.Int32,System.Int32)">
            <summary>
            Reshapes the matrix to a 3D tensor, treating each column as a depth slice in the new 3D tensor
            </summary>
            <param name="rows">Row count of each sub matrix</param>
            <param name="columns">Column count of each sub matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IMatrix.ReshapeAs4DTensor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts the matrix to a 4D tensor, treating each column as a 3D tensor
            </summary>
            <param name="rows">Row count of each sub matrix</param>
            <param name="columns">Column count of each sub matrix</param>
            <param name="depth">Depth of each 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IMatrix.GetAt(System.Int32,System.Int32)">
            <summary>
            Returns the value at the specified row and column index
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IMatrix.SetAt(System.Int32,System.Int32,System.Single)">
            <summary>
            Updates the value at the specified row and column index
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:BrightWire.IMatrix.ColumnVectors">
            <summary>
            Returns the columns of the matrix as vectors
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IMatrix.RowVectors">
            <summary>
            Returns the rows of the matrix as vectors
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IIndexableMatrix">
            <summary>
            A matrix whose elements can be indexed directly
            </summary>
        </member>
        <member name="P:BrightWire.IIndexableMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns an element from the current matrix
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
        </member>
        <member name="P:BrightWire.IIndexableMatrix.Rows">
            <summary>
            Returns the rows of the current matrix as vectors
            </summary>
        </member>
        <member name="P:BrightWire.IIndexableMatrix.Columns">
            <summary>
            Returns the columns of the current matrix as vectors
            </summary>
        </member>
        <member name="P:BrightWire.IIndexableMatrix.Values">
            <summary>
            Returns each element in the current matrix as enumerable
            </summary>
        </member>
        <member name="M:BrightWire.IIndexableMatrix.Map(System.Func{System.Single,System.Single})">
            <summary>
            Mutates each element of the current matrix
            </summary>
            <param name="mutator">The function to apply to each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IIndexableMatrix.MapIndexed(System.Func{System.Int32,System.Int32,System.Single,System.Single})">
            <summary>
            Mutates each element of the current matrix
            </summary>
            <param name="mutator">The function to apply to each element (rowIndex: int, columnIndex: int, value: float) => float</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.IIndexableMatrix.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightWire.IIndexableMatrix.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the matrix as well)
            </summary>
        </member>
        <member name="T:BrightWire.I3DTensor">
            <summary>
            A list of matrices
            </summary>
        </member>
        <member name="P:BrightWire.I3DTensor.RowCount">
            <summary>
            The number of rows in each matrix
            </summary>
        </member>
        <member name="P:BrightWire.I3DTensor.ColumnCount">
            <summary>
            The number of columns in each matrix
            </summary>
        </member>
        <member name="P:BrightWire.I3DTensor.Depth">
            <summary>
            The number of matrices
            </summary>
        </member>
        <member name="P:BrightWire.I3DTensor.Data">
            <summary>
            Converts the current tensor to protobuf format
            </summary>
        </member>
        <member name="M:BrightWire.I3DTensor.GetMatrixAt(System.Int32)">
            <summary>
            Returns a matrix at the specified depth
            </summary>
            <param name="depth">The depth to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.AsIndexable">
            <summary>
            Returns an indexable 3D tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.AddPadding(System.Int32)">
            <summary>
            Adds padding to each matrix
            </summary>
            <param name="padding">The padding (both vertical and horizontal)</param>
            <returns>A new tensor</returns>
        </member>
        <member name="M:BrightWire.I3DTensor.RemovePadding(System.Int32)">
            <summary>
            Removes padding from each matrix
            </summary>
            <param name="padding">The padding to remove</param>
            <returns>A new tensor</returns>
        </member>
        <member name="M:BrightWire.I3DTensor.Im2Col(System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs a convolution on each source matrix
            </summary>
            <param name="filterWidth">The filter width</param>
            <param name="filterHeight">The filter height</param>
            <param name="stride">The convolution stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.ReshapeAsVector">
            <summary>
            Converts the tensor to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.ReshapeAsMatrix">
            <summary>
            Converts the tensor to a matrix (each depth slice becomes a column in the new matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.ReshapeAs4DTensor(System.Int32,System.Int32)">
            <summary>
            Reshapes the 3D tensor into a 4D tensor (the current depth becomes the count of 3D tensors and columns becomes the new depth)
            </summary>
            <param name="rows">Rows in each 4D tensor</param>
            <param name="columns">Columns in each 4D tensor</param>
        </member>
        <member name="M:BrightWire.I3DTensor.MaxPool(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Performs a max pooling operation on the tensor
            </summary>
            <param name="filterWidth">The pooling filter width</param>
            <param name="filterHeight">The pooling filter height</param>
            <param name="stride">The pooling stride</param>
            <param name="saveIndices">True to save the indices for a future reverse max pool operation</param>
            <returns>A max pooled tensor</returns>
        </member>
        <member name="M:BrightWire.I3DTensor.ReverseMaxPool(BrightWire.I3DTensor,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Reverses a max pooling operation
            </summary>
            <param name="outputRows">Input rows</param>
            <param name="outputColumns">Input columns</param>
            <param name="indices">A tensor that contains the indices of each maximum value that was found per filter</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="stride">Filter stride</param>
        </member>
        <member name="M:BrightWire.I3DTensor.ReverseIm2Col(BrightWire.IMatrix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Reverses a im2col operation
            </summary>
            <param name="filter">The rotated filters</param>
            <param name="outputRows">Rows of the input tensor</param>
            <param name="outputColumns">Columns of the input tensor</param>
            <param name="outputDepth">Depth of the input tensor</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="stride">Filter stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.CombineDepthSlices">
            <summary>
            Adds each depth slice into a single matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.AddInPlace(BrightWire.I3DTensor)">
            <summary>
            Adds the other tensor to the current tensor
            </summary>
            <param name="tensor">Tensor to add</param>
        </member>
        <member name="M:BrightWire.I3DTensor.Multiply(BrightWire.IMatrix)">
            <summary>
            Multiplies the tensor with the other matrix
            </summary>
            <param name="matrix">Matrix to multiply with</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I3DTensor.AddToEachRow(BrightWire.IVector)">
            <summary>
            Adds the vector to each row of the tensor
            </summary>
            <param name="vector">Vector to add to each row</param>
        </member>
        <member name="M:BrightWire.I3DTensor.TransposeThisAndMultiply(BrightWire.I4DTensor)">
            <summary>
            Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)
            </summary>
            <param name="tensor">Tensor to multiply with</param>
        </member>
        <member name="T:BrightWire.IIndexable3DTensor">
            <summary>
            A 3D tensor that can be directly indexed
            </summary>
        </member>
        <member name="P:BrightWire.IIndexable3DTensor.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="row">The row to query</param>
            <param name="column">The column to query</param>
            <param name="depth">The depth to query</param>
        </member>
        <member name="P:BrightWire.IIndexable3DTensor.Matrix">
            <summary>
            Gets a list of the indexable matrices
            </summary>
        </member>
        <member name="P:BrightWire.IIndexable3DTensor.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightWire.IIndexable3DTensor.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the tensor as well)
            </summary>
        </member>
        <member name="T:BrightWire.I4DTensor">
            <summary>
            A list of 3D tensors
            </summary>
        </member>
        <member name="P:BrightWire.I4DTensor.RowCount">
            <summary>
            The number of rows in each 3D tensor
            </summary>
        </member>
        <member name="P:BrightWire.I4DTensor.ColumnCount">
            <summary>
            The number of columns in each 3D tensor
            </summary>
        </member>
        <member name="P:BrightWire.I4DTensor.Depth">
            <summary>
            The depth of each 3D tensor
            </summary>
        </member>
        <member name="P:BrightWire.I4DTensor.Count">
            <summary>
            The count of 3D tensors
            </summary>
        </member>
        <member name="M:BrightWire.I4DTensor.GetTensorAt(System.Int32)">
            <summary>
            Returns the tensor at the specified index
            </summary>
            <param name="index">The index to query</param>
        </member>
        <member name="M:BrightWire.I4DTensor.AsIndexable">
            <summary>
            Returns an indexable list of 3D tensors
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I4DTensor.AddPadding(System.Int32)">
            <summary>
            Adds padding to the 4D tensor
            </summary>
            <param name="padding">Padding to add to the left, top, right and bottom edges of the tensor</param>
            <returns>A new tensor with the padding added</returns>
        </member>
        <member name="M:BrightWire.I4DTensor.RemovePadding(System.Int32)">
            <summary>
            Removes padding from the 4D tensor
            </summary>
            <param name="padding">Padding to remove from the left, top, right and bottom edges of the tensor</param>
            <returns>A new tensor with the padding removed</returns>
        </member>
        <member name="M:BrightWire.I4DTensor.MaxPool(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Applies a max pooling operation to the current tensor
            </summary>
            <param name="filterWidth">Max pool filter width</param>
            <param name="filterHeight">Max pool filter height</param>
            <param name="stride">Filter stride</param>
            <param name="saveIndices">True to save the indices for a future reverse pool operation</param>
        </member>
        <member name="M:BrightWire.I4DTensor.ReverseMaxPool(BrightWire.I4DTensor,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Reverses a max pool operation
            </summary>
            <param name="outputRows">Input tensor rows</param>
            <param name="outputColumns">Input tensor columns</param>
            <param name="indices">Tensor of indices from MaxPool operation</param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="stride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I4DTensor.Im2Col(System.Int32,System.Int32,System.Int32)">
            <summary>
            Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix
            </summary>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="stride">Filter stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I4DTensor.ReverseIm2Col(BrightWire.IMatrix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Reverse a previously applied im2Col
            </summary>
            <param name="filter">List of filters that have been rotated 180 degrees</param>
            <param name="outputRows">Rows of the input 4D tensor</param>
            <param name="outputColumns">Columns of the input 4D tensor</param>
            <param name="outputDepth">Depth of the input 4D tensor</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="stride">Filter stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I4DTensor.ColumnSums">
            <summary>
            Sums the columns of each sub-tensor's sub matrix
            </summary>
        </member>
        <member name="M:BrightWire.I4DTensor.ReshapeAsVector">
            <summary>
            Converts the tensor to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.I4DTensor.ReshapeAsMatrix">
            <summary>
            Converts the tensor to a matrix (each 3D tensor becomes a column in the new matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightWire.I4DTensor.Data">
            <summary>
            Converts the current tensor to protobuf format
            </summary>
        </member>
        <member name="T:BrightWire.IIndexable4DTensor">
            <summary>
            A 4D tensor that can be directly indexed
            </summary>
        </member>
        <member name="P:BrightWire.IIndexable4DTensor.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="row">The row to query</param>
            <param name="column">The column to query</param>
            <param name="depth">The depth to query</param>
            <param name="index">The tensor index to query</param>
        </member>
        <member name="P:BrightWire.IIndexable4DTensor.Tensors">
            <summary>
            Gets a list of the indexable matrices
            </summary>
        </member>
        <member name="P:BrightWire.IIndexable4DTensor.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightWire.IIndexable4DTensor.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the tensor as well)
            </summary>
        </member>
        <member name="T:BrightWire.IErrorMetric">
            <summary>
            Error metrics used to quantify machine learning
            </summary>
        </member>
        <member name="P:BrightWire.IErrorMetric.DisplayAsPercentage">
            <summary>
            True if the result should be formatted as a percentage
            </summary>
        </member>
        <member name="M:BrightWire.IErrorMetric.Compute(BrightWire.Models.FloatVector,BrightWire.Models.FloatVector)">
            <summary>
            Computes the error between the output vector and target vector
            </summary>
            <param name="output">The vector that was the output of the model</param>
            <param name="targetOutput">The vector that the model was expected to output</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IErrorMetric.CalculateGradient(BrightWire.IContext,BrightWire.IMatrix,BrightWire.IMatrix)">
            <summary>
            Calculates the gradient of the error function
            </summary>
            <param name="context">The graph context</param>
            <param name="output">The mini batch of output vectors</param>
            <param name="targetOutput">The mini batch of expected target vectors</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IRandomProjection">
            <summary>
            Random projection
            </summary>
        </member>
        <member name="P:BrightWire.IRandomProjection.Size">
            <summary>
            The size to reduce to
            </summary>
        </member>
        <member name="P:BrightWire.IRandomProjection.Matrix">
            <summary>
            The transformation matrix
            </summary>
        </member>
        <member name="M:BrightWire.IRandomProjection.Compute(BrightWire.IVector)">
            <summary>
            Reduces a vector
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IRandomProjection.Compute(BrightWire.IMatrix)">
            <summary>
            Reduces a matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer`1">
            <summary>
            Markov model trainer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a sequence of items to the trainer
            </summary>
            <param name="items"></param>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer2`1">
            <summary>
            Markov model trainer (window size 2)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer2`1.Build">
            <summary>
            Gets all current observations
            </summary>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer3`1">
            <summary>
            Markov model trainer (window size 3)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer3`1.Build">
            <summary>
            Gets all current observations
            </summary>
        </member>
        <member name="T:BrightWire.TrainingErrorCalculation">
            <summary>
            Describes how to calculate the training error
            </summary>
        </member>
        <member name="F:BrightWire.TrainingErrorCalculation.None">
            <summary>
            Do not calculate the training error
            </summary>
        </member>
        <member name="F:BrightWire.TrainingErrorCalculation.Fast">
            <summary>
            Compare the output against the target output and calculate the euclidean distance
            </summary>
        </member>
        <member name="F:BrightWire.TrainingErrorCalculation.TrainingData">
            <summary>
            Execute the model against the training data
            </summary>
        </member>
        <member name="T:BrightWire.ILearningContext">
            <summary>
            Graph learning context
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.EpochSeconds">
            <summary>
            The duration in seconds of the last epoch
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.EpochMilliseconds">
            <summary>
            The duration in milliseconds of the last epoch
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.LinearAlgebraProvider">
            <summary>
            The linear algebra provider
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.CurrentEpoch">
            <summary>
            The index of the current epoch (starting from one)
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.LearningRate">
            <summary>
            The current learning/training rate
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.BatchLearningRate">
            <summary>
            The learning rate adjusted with the current batch size
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.BatchSize">
            <summary>
            The current mini batch size
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.RowCount">
            <summary>
            The total number of rows per epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.StoreUpdate``1(BrightWire.INode,``0,System.Action{``0})">
            <summary>
            Stores an update to the model parameters
            </summary>
            <typeparam name="T">The type of update</typeparam>
            <param name="fromNode">The node that is affected by this update</param>
            <param name="update">The update</param>
            <param name="updater">Callback to execute the update</param>
        </member>
        <member name="P:BrightWire.ILearningContext.TrainingErrorCalculation">
            <summary>
            True if the graph should calculate training error
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.DeferUpdates">
            <summary>
            True if updates are deferred until the mini batch is complete
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.ApplyUpdates">
            <summary>
            Apply any deferred updates
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.StartEpoch">
            <summary>
            Start a new epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.EndEpoch">
            <summary>
            End the current epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.SetRowCount(System.Int32)">
            <summary>
            Sets the number of rows
            </summary>
            <param name="rowCount">The number of rows per epoch</param>
        </member>
        <member name="M:BrightWire.ILearningContext.DeferBackpropagation(BrightWire.IGraphData,System.Action{BrightWire.IGraphData})">
            <summary>
            Register the backpropagation to be deferred
            </summary>
            <param name="errorSignal">The error signal associated with this backpropagation (optional, can be null)</param>
            <param name="update">The callback to execute the backpropagation</param>
        </member>
        <member name="M:BrightWire.ILearningContext.BackpropagateThroughTime(BrightWire.IGraphData,System.Int32)">
            <summary>
            Backpropagates the error signal across all deferred backpropagations
            </summary>
            <param name="signal">The backpropagation signal</param>
            <param name="maxDepth">The maximum depth to backpropagate the signal</param>
        </member>
        <member name="M:BrightWire.ILearningContext.ScheduleLearningRate(System.Int32,System.Single)">
            <summary>
            Schedules a change in the learning rate the specified epoch
            </summary>
            <param name="atEpoch">The epoch to change the learning rate</param>
            <param name="newLearningRate">The learning rate to use at that epoch</param>
        </member>
        <member name="M:BrightWire.ILearningContext.EnableNodeUpdates(BrightWire.INode,System.Boolean)">
            <summary>
            Enable or disable node parameter updates
            </summary>
            <param name="node">The node to modify</param>
            <param name="enableUpdates">True if the node can make updates via backpropagation</param>
        </member>
        <member name="M:BrightWire.ILearningContext.Clear">
            <summary>
            Resets the learning context
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.MessageLog">
            <summary>
            Sends the message to some output
            </summary>
        </member>
        <member name="E:BrightWire.ILearningContext.BeforeEpochStarts">
            <summary>
            Fired before each epoch starts
            </summary>
        </member>
        <member name="E:BrightWire.ILearningContext.AfterEpochEnds">
            <summary>
            Fired after each epoch ends
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.ErrorMetric">
            <summary>
            Error metric to use when evaluating trainging progress
            </summary>
        </member>
        <member name="T:BrightWire.IGradientDescentOptimisation">
            <summary>
            Gradient descent optimisation
            </summary>
        </member>
        <member name="M:BrightWire.IGradientDescentOptimisation.Update(BrightWire.IMatrix,BrightWire.IMatrix,BrightWire.ILearningContext)">
            <summary>
            Updates the matrix with the delta
            </summary>
            <param name="source">The matrix to update</param>
            <param name="delta">The delta matrix</param>
            <param name="context">The graph learning context</param>
        </member>
        <member name="T:BrightWire.ICreateGradientDescent">
            <summary>
            Creates a gradient descent optimisation
            </summary>
        </member>
        <member name="M:BrightWire.ICreateGradientDescent.Create(BrightWire.IPropertySet)">
            <summary>
            Creates the gradient descent optimisation
            </summary>
            <param name="propertySet">The property set that contains initialisation parameters</param>
        </member>
        <member name="T:BrightWire.ICreateTemplateBasedGradientDescent">
            <summary>
            Creates gradient descent optimisations based on a matrix
            </summary>
        </member>
        <member name="M:BrightWire.ICreateTemplateBasedGradientDescent.Create(BrightWire.IGradientDescentOptimisation,BrightWire.IMatrix,BrightWire.IPropertySet)">
            <summary>
            Creates the gradient descent optimisation for a particular target matrix
            </summary>
            <param name="prev">Any other previously created gradient descent optimisation in this context</param>
            <param name="template">The instance of the matrix that will be updated</param>
            <param name="propertySet">The property set that contains initialisation parameters</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IPropertySet">
            <summary>
            The current set of graph initialisation parameters
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.LinearAlgebraProvider">
            <summary>
            The linear algebra provider to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.WeightInitialisation">
            <summary>
            The weight initialiser to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.GradientDescent">
            <summary>
            The gradient descent optimisation to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.TemplateGradientDescentDescriptor">
            <summary>
            The template based gradient descent optimisation to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.GradientDescentDescriptor">
            <summary>
            The descriptor to create new gradient descent optimisations
            </summary>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.ICreateTemplateBasedGradientDescent)">
            <summary>
            Use the specified template based gradient descent optimisation
            </summary>
            <param name="descriptor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.ICreateGradientDescent)">
            <summary>
            Use the specified gradient descent optimisation
            </summary>
            <param name="descriptor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.IGradientDescentOptimisation)">
            <summary>
            Use the specified gradient descent optimisation
            </summary>
            <param name="optimisation"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.IWeightInitialisation)">
            <summary>
            Use the specified weight initialiser
            </summary>
            <param name="weightInit"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Clone">
            <summary>
            Clones the current property set
            </summary>
            <returns>Shallow copy of the current properties</returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Get``1(System.String,``0)">
            <summary>
            Gets a named property
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="name">The property name</param>
            <param name="defaultValue">The value to use if the property has not been supplied</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Set``1(System.String,``0)">
            <summary>
            Sets a named property
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="name">The property name</param>
            <param name="obj">The property value</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Clear(System.String)">
            <summary>
            Clears the named property
            </summary>
            <param name="name">The property name</param>
        </member>
        <member name="T:BrightWire.GaussianVarianceCalibration">
            <summary>
            Gaussian weight initialisation type
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCalibration.SquareRootN">
            <summary>
            Variances are calibrated by dividing by the square root of the connection count
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCalibration.SquareRoot2N">
            <summary>
            Variances are calibrated by multiplying by twice the square root of the connection count
            </summary>
        </member>
        <member name="T:BrightWire.GaussianVarianceCount">
            <summary>
            Gaussian variance count
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.None">
            <summary>
            No variance calibration is applied
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanIn">
            <summary>
            The count of incoming connections is used
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanOut">
            <summary>
            The count of outgoing connections is used
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanInFanOut">
            <summary>
            The count incoming and outgoing connections is used
            </summary>
        </member>
        <member name="T:BrightWire.IWeightInitialisation">
            <summary>
            Neural network weight initialiser
            </summary>
        </member>
        <member name="M:BrightWire.IWeightInitialisation.CreateBias(System.Int32)">
            <summary>
            Creates the bias vector
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:BrightWire.IWeightInitialisation.CreateWeight(System.Int32,System.Int32)">
            <summary>
            Creates the weight matrix
            </summary>
            <param name="rows">Row count</param>
            <param name="columns">Column count</param>
        </member>
        <member name="T:BrightWire.ILogisticRegressionClassifier">
            <summary>
            Logistic regression classifier
            </summary>
        </member>
        <member name="M:BrightWire.ILogisticRegressionClassifier.Predict(System.Single[])">
            <summary>
            Outputs a value from 0 to 1
            </summary>
            <param name="vals">Input data</param>
        </member>
        <member name="M:BrightWire.ILogisticRegressionClassifier.Predict(System.Collections.Generic.IReadOnlyList{System.Single})">
            <summary>
            Outputs a value from 0 to 1
            </summary>
            <param name="vals">Input data</param>
        </member>
        <member name="M:BrightWire.ILogisticRegressionClassifier.Predict(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{System.Single}})">
            <summary>
            Outputs a list of values from 0 to 1 for each input data
            </summary>
            <param name="input">Input data</param>
        </member>
        <member name="T:BrightWire.ILinearRegressionPredictor">
            <summary>
            Linear regression predictor
            </summary>
        </member>
        <member name="M:BrightWire.ILinearRegressionPredictor.Predict(System.Single[])">
            <summary>
            Predicts a value from input data
            </summary>
            <param name="vals">The input data</param>
        </member>
        <member name="M:BrightWire.ILinearRegressionPredictor.Predict(System.Collections.Generic.IReadOnlyList{System.Single})">
            <summary>
            Predicts a value from input data
            </summary>
            <param name="vals">The input data</param>
        </member>
        <member name="M:BrightWire.ILinearRegressionPredictor.Predict(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{System.Single}})">
            <summary>
            Bulk value prediction
            </summary>
            <param name="input">List of data to predict</param>
            <returns>List of predictions</returns>
        </member>
        <member name="T:BrightWire.ILogisticRegressionTrainer">
            <summary>
            A logistic regression trainer
            </summary>
        </member>
        <member name="M:BrightWire.ILogisticRegressionTrainer.GradientDescent(System.Int32,System.Single,System.Single,System.Func{System.Single,System.Boolean})">
            <summary>
            Trains a model using gradient descent
            </summary>
            <param name="iterations">Number of training epochs</param>
            <param name="learningRate">The training rate</param>
            <param name="lambda">Regularisation lambda</param>
            <param name="costCallback">Callback with current cost - False to stop training</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ILogisticRegressionTrainer.ComputeCost(BrightWire.IVector,System.Single)">
            <summary>
            Computes the cost of the specified parameters
            </summary>
            <param name="theta">The model parameters</param>
            <param name="lambda">Regularisation lambda</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ILinearRegressionTrainer">
            <summary>
            Trainer for linear regression models
            </summary>
        </member>
        <member name="M:BrightWire.ILinearRegressionTrainer.GradientDescent(System.Int32,System.Single,System.Single,System.Func{System.Single,System.Boolean})">
            <summary>
            Solves the model using gradient descent
            </summary>
            <param name="iterations">Number of training epochs</param>
            <param name="learningRate">The training rate</param>
            <param name="lambda">Regularisation lambda</param>
            <param name="costCallback">Callback with current cost - False to stop training</param>
            <returns>A trained model</returns>
        </member>
        <member name="M:BrightWire.ILinearRegressionTrainer.ComputeCost(BrightWire.IVector,System.Single)">
            <summary>
            Computes the cost of the specified parameters
            </summary>
            <param name="theta">The model parameters</param>
            <param name="lambda">Regularisation lambda</param>
        </member>
        <member name="T:BrightWire.IIndexListEncoder">
            <summary>
            Encodes index lists to dense vectors
            </summary>
        </member>
        <member name="M:BrightWire.IIndexListEncoder.Encode(BrightWire.Models.IndexList)">
            <summary>
            Encodes the index lists to a dense vector
            </summary>
            <param name="indexList">The index list to encode</param>
        </member>
        <member name="T:BrightWire.IWeightedIndexListEncoder">
            <summary>
            Encodes weighted index lists to dense vectors
            </summary>
        </member>
        <member name="M:BrightWire.IWeightedIndexListEncoder.Encode(BrightWire.Models.WeightedIndexList)">
            <summary>
            Encodes the weighted index list to a dense vector
            </summary>
            <param name="indexList"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IRowEncoder">
            <summary>
            Encodes data table rows to dense vectors
            </summary>
        </member>
        <member name="M:BrightWire.IRowEncoder.Encode(BrightWire.IRow)">
            <summary>
            Encodes a data table row to a dense vector
            </summary>
            <param name="row">The row to encode</param>
        </member>
        <member name="T:BrightWire.IHaveDataTableVectoriser">
            <summary>
            An interface to retrieve the implicitly created vectorised for non linear algebra data tables
            </summary>
        </member>
        <member name="P:BrightWire.IHaveDataTableVectoriser.Vectoriser">
            <summary>
            The implicitly created data table vectoriser
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.Cpu3DTensor">
            <summary>
            3D Tensor that uses the CPU based math.net numerics library
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.Cpu4DTensor">
            <summary>
            4D Tensor that uses the CPU based math.net numerics library
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.CpuMatrix">
            <summary>
            Matrix that uses the CPU based math.net numerics library
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.CpuProvider">
            <summary>
            Creates vectors, matrices and tensors using the CPU based math.net numerics library
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.CpuVector">
            <summary>
            Vector that uses the CPU based math.net numerics library
            </summary>
        </member>
        <member name="T:BrightWire.LinearAlgebra.Helper.BoundMath">
            <summary>
            Floating point helper that prevents values from getting too big or small
            </summary>
        </member>
        <member name="F:BrightWire.LinearAlgebra.Helper.BoundMath.TOO_SMALL">
            <summary>
            Minimum value
            </summary>
        </member>
        <member name="F:BrightWire.LinearAlgebra.Helper.BoundMath.TOO_BIG">
            <summary>
            Maximum value
            </summary>
        </member>
        <member name="F:BrightWire.LinearAlgebra.Helper.BoundMath.ZERO_LIKE">
            <summary>
            Tolerance for comparison to zero
            </summary>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.Constrain(System.Single)">
            <summary>
            Forces the value to lie within the valid range
            </summary>
            <param name="val">Value to check</param>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.Exp(System.Single)">
            <summary>
            Bounded exponent
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.Log(System.Single)">
            <summary>
            Bounded natural log
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.Pow(System.Single,System.Single)">
            <summary>
            Bounded power
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.IsZero(System.Single)">
            <summary>
            Returns true if the value approximates zero
            </summary>
            <param name="value">Value to test</param>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.IsNotZero(System.Single)">
            <summary>
            Returns true if the value is greater than zero
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.AreEqual(System.Single,System.Single,System.Single)">
            <summary>
            Checks if the two floating point numbers are equal (with a degree of tolerance)
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">Tolerance allowed between the numbers</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.LinearAlgebra.Helper.BoundMath.GetEqualityComparer(System.Single)">
            <summary>
            Used for comparing floating point numbers (if they are within the tolerance they are considered equal)
            </summary>
            <param name="tolerance">Tolerance to consider if two floating point numbers are the same</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Linear.LogisticRegressionPredictor">
            <summary>
            Makes predictions from a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.Linear.MultinomialLogisticRegressionClassifier">
            <summary>
            Makes predictions from a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.Linear.RegressionPredictor">
            <summary>
            Makes predictions from a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.Linear.Training.LogisticRegressionTrainer">
            <summary>
            Logistic regression
            https://en.wikipedia.org/wiki/Logistic_regression
            </summary>
        </member>
        <member name="T:BrightWire.Linear.Training.MultinomialLogisticRegressionTrainner">
            <summary>
            Logistic regression with multiple possible classifications
            </summary>
        </member>
        <member name="T:BrightWire.Linear.Training.RegressionTrainer">
            <summary>
            Linear regression
            https://en.wikipedia.org/wiki/Linear_regression
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes">
            <summary>
            A bernoulli naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability">
            <summary>
            The probabilities associated with a string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.StringIndex">
            <summary>
            The string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.ConditionalProbability">
            <summary>
            The log of the conditional probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.InverseProbability">
            <summary>
            The log of the inverse conditional probability
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class">
            <summary>
            A classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Prior">
            <summary>
            The log of the prior probablilty for this classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.MissingProbability">
            <summary>
            The log of the missing probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Index">
            <summary>
            The list of probabilities for each string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.InverseMissingProbability">
            <summary>
            The log of the inverse missing probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.ClassData">
            <summary>
            Classification data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Vocabulary">
            <summary>
            The list of string indexes that were in the training set
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from this model
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelStateTransition`1">
            <summary>
            A markov model state transition
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.NextState">
            <summary>
            The next state
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.Probability">
            <summary>
            The probability of this next state
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelObservation2`1">
            <summary>
            A markov model observation based on the preceding two items
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Item1">
            <summary>
            The second last preceding item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Item2">
            <summary>
            The last preceding item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Transition">
            <summary>
            The list of possible transitions from this state
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Equals(System.Object)">
            <summary>
            Equals overide
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation2`1.GetHashCode">
            <summary>
            Hash code override
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModel2`1">
            <summary>
            A markov model based on observing two items at a time
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel2`1.Observation">
            <summary>
            The list of observations
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel2`1.AsDictionary">
            <summary>
            Converts the model to a dictionary
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelObservation3`1">
            <summary>
            A markov model observation based on the preceding three instances
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item1">
            <summary>
            The third last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item2">
            <summary>
            The second last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item3">
            <summary>
            The third last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Transition">
            <summary>
            The list of associated transitions
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation3`1.GetHashCode">
            <summary>
            Hashcode override
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModel3`1">
            <summary>
            A markov model based on observing the last three observations
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel3`1.Observation">
            <summary>
            The list of observations
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel3`1.AsDictionary">
            <summary>
            Converts the model to a dictionary
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes">
            <summary>
            Multinomial naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability">
            <summary>
            The conditional probability associated with a string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.StringIndex">
            <summary>
            The string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.ConditionalProbability">
            <summary>
            The conditional probability
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class">
            <summary>
            Classification data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Prior">
            <summary>
            The classification's prior log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.MissingProbability">
            <summary>
            The classifications missing log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Index">
            <summary>
            The list of string indexes and their probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.ClassData">
            <summary>
            The list of possible classifications
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes">
            <summary>
            A naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
            <summary>
            The type of data within the column
            </summary>
        </member>
        <member name="F:BrightWire.Models.Bayesian.NaiveBayes.ColumnType.ContinuousGaussian">
            <summary>
            Continuous values
            </summary>
        </member>
        <member name="F:BrightWire.Models.Bayesian.NaiveBayes.ColumnType.Categorical">
            <summary>
            Categorical values
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.Column">
            <summary>
            A column within the naive bayes model
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.ColumnIndex">
            <summary>
            Index within the data set
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Type">
            <summary>
            Type of column (categorical or continuous)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Variance">
            <summary>
            The variance of the column values (continuous only)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Mean">
            <summary>
            The mean of the column values (continuous only)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Probability">
            <summary>
            The list of categories within the column and their probability (categorical only)
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability">
            <summary>
            A category and its associated log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability.Category">
            <summary>
            The category label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability.LogProbability">
            <summary>
            The natural log of the category's probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability.Probability">
            <summary>
            The category's probability
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary">
            <summary>
            A classification and its associated data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.LogPrior">
            <summary>
            The natural log of the prior
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.ColumnSummary">
            <summary>
            The column data associated with this classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.Prior">
            <summary>
            The classification prior probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Class">
            <summary>
            A list of possible classifications and their data
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from this model
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.ConfusionMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="M:BrightWire.Models.ConfusionMatrix.GetCount(System.String,System.String)">
            <summary>
            Returns the count of the expected vs actual classifications
            </summary>
            <param name="expected">Expected classification label</param>
            <param name="actual">Actual classification label</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.DataSourceModel">
            <summary>
            Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Version">
            <summary>
            Data contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Name">
            <summary>
            The name of the data source
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.InputSize">
            <summary>
            The size of each input training data item
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.OutputSize">
            <summary>
            The size of each training item output (classification label)
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Graph">
            <summary>
            The preliminary graph
            </summary>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableNormalisation">
            <summary>
            A data table normalisation model
            </summary>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableNormalisation.Column">
            <summary>
            A column model
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.Column.ColumnIndex">
            <summary>
            The column index
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.Column.DataType">
            <summary>
            The type of data in the column
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.Column.Subtract">
            <summary>
            The value to subtract from the column
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.Column.Divide">
            <summary>
            The value to divide the column with (after subtraction)
            </summary>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.Column.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.Column.#ctor(System.Int32,BrightWire.ColumnType,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="columnIndex"></param>
            <param name="dataType"></param>
            <param name="divide"></param>
            <param name="subtract"></param>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.Column.Normalise(System.Double)">
            <summary>
            Perform the normalisation step
            </summary>
            <param name="val">The input value</param>
            <returns>The normalused input value</returns>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.Column.ReverseNormalise(System.Double)">
            <summary>
            Applies the normalisation in reverse
            </summary>
            <param name="val">Value to transform</param>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableNormalisation.VectorColumn">
            <summary>
            A vector based column to normalise
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.VectorColumn.ColumnIndex">
            <summary>
            The column index
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.VectorColumn.VectorColumns">
            <summary>
            The normalisation data within the vector (each index within the vector becomes a "column")
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.Type">
            <summary>
            The type of normalisation
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.ColumnNormalisation">
            <summary>
            The column normalisation data
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableNormalisation.VectorColumnNormalisation">
            <summary>
            Vector columns normalisation data
            </summary>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.Normalise(System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            Normalises a row in the data table
            </summary>
            <param name="row">The row to normalise</param>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableNormalisation.ReverseNormalise(System.Int32,System.Object)">
            <summary>
            Applies the normalisation in reverse
            </summary>
            <param name="columnIndex">Column index in original table</param>
            <param name="val">Value to normalise</param>
            <returns>Reverse normalised value</returns>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableVectorisation">
            <summary>
            A data table vectorisation model - maps rows in a data table to vectors
            </summary>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableVectorisation.CategoricalIndex">
            <summary>
            A categorical column value
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.CategoricalIndex.Category">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.CategoricalIndex.Index">
            <summary>
            The label's index
            </summary>
        </member>
        <member name="T:BrightWire.Models.DataTable.DataTableVectorisation.Column">
            <summary>
            Column information
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.ColumnIndex">
            <summary>
            The column index
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.IsTargetColumn">
            <summary>
            True if the column is the classification target
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.IsContinuous">
            <summary>
            True if the column has a continuous value
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.Size">
            <summary>
            The number of slots this column will fill in the output vector
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.Values">
            <summary>
            An array of categorial values
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Column.IsBinary">
            <summary>
            True if the column has one of two possible values
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.Columns">
            <summary>
            The columns in the table
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.InputSize">
            <summary>
            The size of each input vector that will be created
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.OutputSize">
            <summary>
            The size of each output vector that will be created
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.HasTarget">
            <summary>
            True if the vectoriser has a classification target column
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.IsTargetContinuous">
            <summary>
            True if the classification target column is continuous
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.ClassColumnIndex">
            <summary>
            The column index of the classifiation target column
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.IsTargetBinary">
            <summary>
            True if the classification target column has one of two possible values
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.ColumnMap">
            <summary>
            A dictionary of column to categorical value tables
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataTable.DataTableVectorisation.ReverseColumnMap">
            <summary>
            A dictionary of column to reversed categorical value tables
            </summary>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableVectorisation.GetOutputLabel(System.Int32,System.Int32)">
            <summary>
            Returns the classification label for the corresponding column/vector indices
            </summary>
            <param name="columnIndex">The data table column index</param>
            <param name="vectorIndex">The one hot vector index</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableVectorisation.GetInput(BrightWire.IRow)">
            <summary>
            Vectorises the input columns of the specified row
            </summary>
            <param name="row">>The row to vectorise</param>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableVectorisation.GetOutput(BrightWire.IRow)">
            <summary>
            Vectorises the output column of the specified row
            </summary>
            <param name="row">The row to vectorise</param>
        </member>
        <member name="M:BrightWire.Models.DataTable.DataTableVectorisation.ReverseOutput(BrightWire.Models.FloatVector,BrightWire.ColumnType)">
            <summary>
            Converts a float output vector to its original column type
            </summary>
            <param name="vector">Vector to convert</param>
            <param name="targetColumnType">Target column in the original data table</param>
        </member>
        <member name="T:BrightWire.Models.ExecutionGraph">
            <summary>
            A serialised execution graph
            </summary>
        </member>
        <member name="T:BrightWire.Models.ExecutionGraph.Node">
            <summary>
            A node within the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Node.TypeName">
            <summary>
            The .NET type name of the node type
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Node.Id">
            <summary>
            The unique id within the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Node.Name">
            <summary>
            Node friendly name
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Node.Description">
            <summary>
            A short description of the node
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Node.Data">
            <summary>
            The node's parameters
            </summary>
        </member>
        <member name="T:BrightWire.Models.ExecutionGraph.Wire">
            <summary>
            Wires connect nodes (aka edges)
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Wire.FromId">
            <summary>
            The source node id
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Wire.ToId">
            <summary>
            The target node id
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Wire.InputChannel">
            <summary>
            The channel on the target node to send the source node's output
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraph.Wire.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraph.Wire.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraph.Wire.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Version">
            <summary>
            Data contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Name">
            <summary>
            The name of the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.InputNode">
            <summary>
            The primary input node
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.OtherNodes">
            <summary>
            Other connected nodes
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraph.Wires">
            <summary>
            A list of the wires that connect the nodes in the graph
            </summary>
        </member>
        <member name="T:BrightWire.Models.ExecutionResult">
            <summary>
            The output from a mini batch
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionResult.#ctor(BrightWire.IMiniBatchSequence,System.Collections.Generic.IReadOnlyList{BrightWire.Models.FloatVector},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="miniBatch">The mini batch sequence</param>
            <param name="output">The mini batch output</param>
            <param name="index">Output index</param>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Index">
            <summary>
            Output index
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Output">
            <summary>
            The list of output rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Target">
            <summary>
            The list of target rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Input">
            <summary>
            The list of input rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.MiniBatchSequence">
            <summary>
            The mini batch
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionResult.CalculateError(BrightWire.IErrorMetric)">
            <summary>
            Calculates the error of the output against the target
            </summary>
            <param name="errorMetric">The error metric to calculate with</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.FloatMatrix">
            <summary>
            A protobuf serialised matrix
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatMatrix.Row">
            <summary>
            The rows of the matrix
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.Create(BrightWire.Models.FloatVector[])">
            <summary>
            Create a new float matrix with the specified rows
            </summary>
            <param name="rows">The rows in the matrix (each vector should be the same length)</param>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.Create(System.Int32,System.Int32)">
            <summary>
            Create a new float matrix with the specified number of rows and columns initialised to zero
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
        </member>
        <member name="P:BrightWire.Models.FloatMatrix.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatMatrix.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Creates a float matrix from a binary reader
            </summary>
            <param name="reader">The binary reader</param>
        </member>
        <member name="P:BrightWire.Models.FloatMatrix.Xml">
            <summary>
            Converts the matrix to XML
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatMatrix.IsEqualTo(BrightWire.Models.FloatMatrix,System.Collections.Generic.IEqualityComparer{System.Single})">
            <summary>
            Tests if the matrices are the same
            </summary>
            <param name="matrix">The matrix to compare</param>
            <param name="comparer">Optional IEqualityComparer to use</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.FloatTensor">
            <summary>
            A protobuf serialised 3D tensor
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.Matrix">
            <summary>
            The list of matrices that form the tensor
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.Create(BrightWire.Models.FloatMatrix[])">
            <summary>
            Create a new 3D tensor
            </summary>
            <param name="matrices">List of matrices that form the 3D tensor (each should have the same dimensions)</param>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new 3D tensor initialised to zero
            </summary>
            <param name="rowCount">Row count of each matrix</param>
            <param name="columnCount">Column count of each matrix</param>
            <param name="depth">Depth of the 3D tensor (number of matrices)</param>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.Depth">
            <summary>
            The depth of the tensor
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Creates a float tensor from a binary reader
            </summary>
            <param name="reader">The binary reader</param>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.Xml">
            <summary>
            Converts the tensor to XML
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatTensor.Size">
            <summary>
            Number of items in the tensor (depth * rows * columns)
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.GetAsRaw">
            <summary>
            Converts the data to a column major vector
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatTensor.IsEqualTo(BrightWire.Models.FloatTensor,System.Collections.Generic.IEqualityComparer{System.Single})">
            <summary>
            Tests if the tensors are the same
            </summary>
            <param name="tensor">The tensor to compare</param>
            <param name="comparer">Optional IEqualityComparer to use</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.FloatVector">
            <summary>
            An protobuf serialised vector
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatVector.Data">
            <summary>
            The data
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatVector.Create(System.Single[])">
            <summary>
            Create a new float vector with the specified data
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.Models.FloatVector.Create(System.Int32)">
            <summary>
            Create a new float vector with each entry set to zero
            </summary>
            <param name="size">Size of the vector</param>
        </member>
        <member name="P:BrightWire.Models.FloatVector.Size">
            <summary>
            (Same as Count) - The number of elements in the vector
            </summary>
        </member>
        <member name="P:BrightWire.Models.FloatVector.Count">
            <summary>
            (Same as Size) - The number of elements in the vector
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatVector.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatVector.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightWire.Models.FloatVector.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.Models.FloatVector.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Creates a float array from a binary reader
            </summary>
            <param name="reader">The binary reader</param>
        </member>
        <member name="P:BrightWire.Models.FloatVector.Xml">
            <summary>
            Converts the vector to XML
            </summary>
        </member>
        <member name="M:BrightWire.Models.FloatVector.IsEqualTo(BrightWire.Models.FloatVector,System.Collections.Generic.IEqualityComparer{System.Single})">
            <summary>
            Tests if the vectors are the same
            </summary>
            <param name="vector">The vector to compare</param>
            <param name="comparer">Optional IEqualityComparer to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.FloatVector.MaximumIndex">
            <summary>
            Finds the index with the highest value
            </summary>
        </member>
        <member name="T:BrightWire.Models.GraphModel">
            <summary>
            A serialised graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Version">
            <summary>
            Data contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Name">
            <summary>
            The name of the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Graph">
            <summary>
            The primary execution graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.DataSource">
            <summary>
            Optional data source associated with the model
            </summary>
        </member>
        <member name="T:BrightWire.Models.IndexList">
            <summary>
            A protobuf serialisable sparse array of indices
            </summary>
        </member>
        <member name="P:BrightWire.Models.IndexList.Index">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="M:BrightWire.Models.IndexList.Create(System.UInt32[])">
            <summary>
            Create a new index list with the specified indices
            </summary>
            <param name="index">Sparse list of indices</param>
        </member>
        <member name="P:BrightWire.Models.IndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightWire.Models.IndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightWire.Models.IndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightWire.Models.IndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.Models.IndexList.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Creates an index list from a binary reader
            </summary>
            <param name="reader">The binary reader</param>
        </member>
        <member name="P:BrightWire.Models.IndexList.Xml">
            <summary>
            Converts the index list to XML
            </summary>
        </member>
        <member name="T:BrightWire.Models.InstanceBased.KNearestNeighbours">
            <summary>
            K Nearest Neighbour Model
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.Instance">
            <summary>
            The list of vectors to match against
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.Classification">
            <summary>
            The corresponding list of classifications
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.FeatureColumn">
            <summary>
            The vector indexes to use to encode a data table row as a vector
            </summary>
        </member>
        <member name="M:BrightWire.Models.InstanceBased.KNearestNeighbours.CreateClassifier(BrightWire.ILinearAlgebraProvider,System.Int32,BrightWire.DistanceMetric)">
            <summary>
            Creates a classifier from this model
            </summary>
            <param name="lap">The linear algebra provider</param>
            <param name="k">The number of instances to consider</param>
            <param name="distanceMetric">The distance metric to compare each row with each instance</param>
        </member>
        <member name="T:BrightWire.Models.LinearRegression">
            <summary>
            A linear regression model
            </summary>
        </member>
        <member name="P:BrightWire.Models.LinearRegression.Theta">
            <summary>
            The model parameters
            </summary>
        </member>
        <member name="M:BrightWire.Models.LinearRegression.CreatePredictor(BrightWire.ILinearAlgebraProvider)">
            <summary>
            Creates a predictor from this model
            </summary>
            <param name="lap">The linear algebra provider</param>
        </member>
        <member name="T:BrightWire.Models.LogisticRegression">
            <summary>
            A logistic regression model
            </summary>
        </member>
        <member name="P:BrightWire.Models.LogisticRegression.Theta">
            <summary>
            The model parameters
            </summary>
        </member>
        <member name="M:BrightWire.Models.LogisticRegression.CreatePredictor(BrightWire.ILinearAlgebraProvider)">
            <summary>
            Creates a classifier from this model
            </summary>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightWire.Models.MultinomialLogisticRegression">
            <summary>
            Multinomial logistic regression model
            </summary>
        </member>
        <member name="P:BrightWire.Models.MultinomialLogisticRegression.Model">
            <summary>
            The list of logistic regression models
            </summary>
        </member>
        <member name="P:BrightWire.Models.MultinomialLogisticRegression.Classification">
            <summary>
            The associated classification labels
            </summary>
        </member>
        <member name="P:BrightWire.Models.MultinomialLogisticRegression.FeatureColumn">
            <summary>
            The columns used to build the dense input vectors
            </summary>
        </member>
        <member name="M:BrightWire.Models.MultinomialLogisticRegression.CreateClassifier(BrightWire.ILinearAlgebraProvider)">
            <summary>
            Creates a classifier from this model
            </summary>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.StringTable">
            <summary>
            An array of indexed strings
            </summary>
        </member>
        <member name="P:BrightWire.Models.StringTable.Data">
            <summary>
            The array of indexed strings
            </summary>
        </member>
        <member name="T:BrightWire.Models.DecisionTree">
            <summary>
            A decision tree model
            </summary>
        </member>
        <member name="T:BrightWire.Models.DecisionTree.Node">
            <summary>
            A node in the decision tree
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Node.Children">
            <summary>
            The nodes children
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Node.ColumnIndex">
            <summary>
            The column index that is being split on
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Node.MatchLabel">
            <summary>
            The value to match this node
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Node.Split">
            <summary>
            The value to split on
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Node.Classification">
            <summary>
            This node's classification label
            </summary>
        </member>
        <member name="M:BrightWire.Models.DecisionTree.Node.WriteTo(System.Xml.XmlWriter)">
            <summary>
            Writes the node as XML
            </summary>
            <param name="writer">The XML writer</param>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.ClassColumnIndex">
            <summary>
            The classification label column index
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.Root">
            <summary>
            The root of the tree
            </summary>
        </member>
        <member name="P:BrightWire.Models.DecisionTree.AsXml">
            <summary>
            Converts the tree to XML
            </summary>
        </member>
        <member name="M:BrightWire.Models.DecisionTree.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.RandomForest">
            <summary>
            A random forest model
            </summary>
        </member>
        <member name="P:BrightWire.Models.RandomForest.Forest">
            <summary>
            The list of trees in the forest
            </summary>
        </member>
        <member name="M:BrightWire.Models.RandomForest.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.WeightedIndexList">
            <summary>
            A protobuf serialisable sparse array of weighted indices
            </summary>
        </member>
        <member name="T:BrightWire.Models.WeightedIndexList.WeightedIndex">
            <summary>
            A weighted index
            </summary>
        </member>
        <member name="P:BrightWire.Models.WeightedIndexList.WeightedIndex.Index">
            <summary>
            Index
            </summary>
        </member>
        <member name="P:BrightWire.Models.WeightedIndexList.WeightedIndex.Weight">
            <summary>
            Index weight
            </summary>
        </member>
        <member name="P:BrightWire.Models.WeightedIndexList.IndexList">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.Create(BrightWire.Models.WeightedIndexList.WeightedIndex[])">
            <summary>
            Create a new weighted index list with the specified weighted indices
            </summary>
            <param name="indexList">Sparse list of weighted indices</param>
        </member>
        <member name="P:BrightWire.Models.WeightedIndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Creates a weighted index list from a binary reader
            </summary>
            <param name="reader">The binary reader</param>
        </member>
        <member name="P:BrightWire.Models.WeightedIndexList.Xml">
            <summary>
            Converts the weighted index list to XML
            </summary>
        </member>
        <member name="M:BrightWire.Models.WeightedIndexList.AsIndexList">
            <summary>
            Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TabularData.Analysis.DataTableAnalysis">
            <summary>
            Collects meta data about data tables
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Analysis.FrequencyCollector">
            <summary>
            A collector that collects the frequency from a single column of a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Analysis.IndexCollector">
            <summary>
            Collects min and max values from the index or weighted index lists of a single column in a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Analysis.NumberCollector">
            <summary>
            Collects standard deviation, mean, mode etc from a single numeric column in a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Analysis.StringCollector">
            <summary>
            Collects min and max lengths and the set of distinct items from a single string column of a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.DataTable">
            <summary>
            Data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.DataTableRow">
            <summary>
            A row within a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.ClassificationBasedRowProcessor">
            <summary>
            Processes rows based on each row's classification label
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.ColumnTypeClassifier">
            <summary>
            Classifies data table column types
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.DataTableNormaliser">
            <summary>
            Builds a normalisation model that can be used to normalise a data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.DataTableProjector">
            <summary>
            Projects a subset of data table rows into a new data table
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.DataTableVectoriser">
            <summary>
            Converts data tables that might contain categorical or sparse vector based data into a dense vector format
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.DataTableWriter">
            <summary>
            Manages writing data tables to streams and building the row index within the saved stream
            </summary>
        </member>
        <member name="T:BrightWire.TabularData.Helper.RowConverter">
            <summary>
            Internal helper class used to improve the performance of data table type conversion
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.And">
            <summary>
            Simple AND training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.And.Get">
            <summary>
            Generates a data table containing AND training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.BinaryIntegers">
            <summary>
            Creates random integers and returns feature vectors against binary mathematical logic
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.BinaryIntegers._GetBitArray(System.Int32)">
            <summary>
            Converts a value to an array of floats, with 1 or 0 for each bit position
            </summary>
            <param name="val">The number to convert</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.BinaryIntegers.Addition(System.Int32,System.Boolean)">
            <summary>
            Creates random integers added together as feature vectors
            The input feature contains two features, one for each bit at that position
            The output feature contains a single feature: 1 or 0 if that bit is set in the result
            </summary>
            <param name="sampleCount">How many samples to generate</param>
            <param name="stochastic">True to generate random integers</param>
            <returns>A list of sequences</returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.Or">
            <summary>
            Simple OR training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.Or.Get">
            <summary>
            Generates a data table containing OR training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.ReberGrammar">
            <summary>
            Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetChar(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">Index to query</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetIndex(System.Char)">
            <summary>
            Gets the index for the specified character
            </summary>
            <param name="ch">The character to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.Encode(System.String)">
            <summary>
            Encodes a reber sequence as a sequence of one hot encoded vectors
            </summary>
            <param name="sequence">The reber sequence to encode</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetOneHot(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            One hot encodes the REBER strings
            </summary>
            <param name="strList">A list of REBER sequences</param>
            <returns>A data table with matrices to represent the sequences of vectors and their corresponding outputs</returns>
        </member>
        <member name="P:BrightWire.TrainingData.Artificial.ReberGrammar.Size">
            <summary>
            The number of REBER characters
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.#ctor(System.Boolean)">
            <summary>
            Creates a reber grammar builder
            </summary>
            <param name="stochastic">True to generate random sequences</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.Get(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Generates an unlimited number of reber sequences
            </summary>
            <param name="minlength">Minimum length of the sequences (optional)</param>
            <param name="maxLength">Mimimum length of the sequences (optional)</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetExtended(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Generates an unlimited number of extended reber sequences
            </summary>
            <param name="minlength">Minimum length of the sequences (optional)</param>
            <param name="maxLength">Mimimum length of the sequences (optional)</param>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.SequenceGenerator">
            <summary>
            Generates random alphabetical sequences
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="dictionarySize">The number of letters to use</param>
            <param name="minSize">The minimum size of each sequence</param>
            <param name="maxSize">The maximum size of each sequence</param>
            <param name="noRepeat">True to avoid repeating any previous character within each sequence</param>
            <param name="isStochastic">True to generate different sequences each time</param>
        </member>
        <member name="P:BrightWire.TrainingData.Artificial.SequenceGenerator.DictionarySize">
            <summary>
            The number of letters to use
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.NextSequence">
            <summary>
            Generates a new sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.Char,System.Single)">
            <summary>
            Converts the character to a one hot encoded vector
            </summary>
            <param name="ch"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Char,System.Single}})">
            <summary>
            Encodes the characters as a dense vector
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.String)">
            <summary>
            Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.GenerateSequences">
            <summary>
            Generator function to generate new sequences
            </summary>
            <returns>Infinite number of sequences</returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.Xor">
            <summary>
            Simple XOR training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.Xor.Get">
            <summary>
            Generates a data table containing XOR training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.BigEndianBinaryReader">
            <summary>
            Binary reader for big endian streams
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new big endian binary reader
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt32">
            <summary>
            Reads an int
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt16">
            <summary>
            Reads a short
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt64">
            <summary>
            Reads a long
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadUInt32">
            <summary>
            Reads a ulong
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.SequenceWindowBuilder">
            <summary>
            Creates a new training feature vector using a window of surrounding features at each point in the input sequence
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SequenceWindowBuilder.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new sequence window builder
            </summary>
            <param name="before">The number of previous items to include before each item</param>
            <param name="after">The number of following items to include after each item</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SequenceWindowBuilder.Get(System.Collections.Generic.IReadOnlyList{System.Single[]})">
            <summary>
            Augments a single sequence
            </summary>
            <param name="data">The sequence to analyse</param>
            <returns>A new sequence, augmented with contextual information</returns>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.SequenceWindowBuilder.OutputSize">
            <summary>
            The size of the generated training data
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.SimpleTokeniser">
            <summary>
            Finds strings of words and numbers in a larger string
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.Tokenise(System.String)">
            <summary>
            Splits the text into smaller word and number strings. Punctuation characters become single character strings.
            </summary>
            <param name="text">The text to tokenise</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.JoinNegations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Simple token modification following "not".
            Double not or punctuation stops the not mode
            </summary>
            <param name="tokenList">The list of tokens</param>
            <returns>A sequence of modified tokens</returns>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.FindSentences(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds sentences from a list of strings
            </summary>
            <param name="stringList">The list of strings</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.IsEndOfSentence(System.String)">
            <summary>
            Checks if the string is an end of sentence token
            </summary>
            <param name="str">The string to check</param>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.StringTableBuilder">
            <summary>
            Assigns string indices to strings
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor">
            <summary>
            Creates an empty string table builder
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor(BrightWire.Models.StringTable)">
            <summary>
            Creates a string table builder pre populated with an existing string table
            </summary>
            <param name="stringTable">The string table to pre populate</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor(System.String[])">
            <summary>
            Creates a string table builder pre populated with an existing string table
            </summary>
            <param name="stringTable">The string table to pre populate</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.TryGetIndex(System.String,System.UInt32@)">
            <summary>
            Returns true if the string has already been added
            </summary>
            <param name="str">The string to check</param>
            <param name="ret">The string index</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.GetIndex(System.String)">
            <summary>
            Gets a string index for a string (creates a new index if not found)
            </summary>
            <param name="str">The string to look up</param>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.StringTableBuilder.StringTable">
            <summary>
            Serialises the string table
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.StringTableBuilder.Size">
            <summary>
            Returns the size of the string table
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.GetString(System.UInt32)">
            <summary>
            Returns the string at the specified index
            </summary>
            <param name="index">The string index</param>
        </member>
        <member name="T:BrightWire.TrainingData.WellKnown.Mnist">
            <summary>
            Helper class for MNIST data: http://yann.lecun.com/exdb/mnist/
            </summary>
        </member>
        <member name="F:BrightWire.TrainingData.WellKnown.Mnist.INPUT_SIZE">
            <summary>
            Input layer size
            </summary>
        </member>
        <member name="F:BrightWire.TrainingData.WellKnown.Mnist.OUTPUT_SIZE">
            <summary>
            Output layer size
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.WellKnown.Mnist.Image">
            <summary>
            Image data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.WellKnown.Mnist.Image.#ctor(System.Byte[],System.Int32)">
            <summary>
            Mnist.Image
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.WellKnown.Mnist.Image.Data">
            <summary>
            The image data
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.WellKnown.Mnist.Image.Label">
            <summary>
            The image number (0-9)
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.WellKnown.Mnist.Image.AsFloatArray">
            <summary>
            Converts the image to one hot encoded float arrays
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.WellKnown.Mnist.Image.AsFloatTensor">
            <summary>
            Converts the image to a tensor with one hot encoded label vector
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.WellKnown.Mnist.Load(System.String,System.String,System.Int32)">
            <summary>
            Loads a set of images from the MNIST data files
            </summary>
            <param name="labelPath">Path to the label data file</param>
            <param name="imagePath">Path to the image data file</param>
            <param name="total">Maximum number of images to load</param>
        </member>
        <member name="T:BrightWire.TreeBased.DecisionTreeClassifier">
            <summary>
            Classifies rows based on a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.RandomForestClassifier">
            <summary>
            Classifies rows based on a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.Training.DecisionTreeTrainer">
            <summary>
            Decision tree classifier
            https://en.wikipedia.org/wiki/Decision_tree_learning
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.Training.RandomForestTrainer">
            <summary>
            Random forest classifier
            https://en.wikipedia.org/wiki/Random_forest
            </summary>
        </member>
        <member name="T:BrightWire.Unsupervised.Hierachical">
            <summary>
            Hierachical clustering
            https://en.wikipedia.org/wiki/Hierarchical_clustering
            </summary>
        </member>
        <member name="T:BrightWire.Unsupervised.KMeans">
            <summary>
            K Means clustering
            https://en.wikipedia.org/wiki/K-means_clustering
            </summary>
        </member>
        <member name="T:BrightWire.Unsupervised.NonNegativeMatrixFactorisation">
            <summary>
            Non negative matrix factorisation based clustering
            https://en.wikipedia.org/wiki/Non-negative_matrix_factorization
            </summary>
        </member>
    </members>
</doc>
